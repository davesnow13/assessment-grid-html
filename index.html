<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snowboard Assessment Grid</title>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg: #f4f6f8;
      --border: #111;
      --muted: #555;
      --incCol: #f8dfe1;   /* light red */
      --conCol: #fbf5d8;   /* light yellow */
      --refiCol:#e4f3e6;   /* light green */

      --incOn: #c84a52;    /* strong red */
      --conOn: #c6a600;    /* strong yellow */
      --refiOn:#2e7d32;    /* strong green */
    }

    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 14px;
      background: var(--bg);
      color: #111;
    }

    h1{ margin: 0 0 4px 0; font-size: 32px; }
    .small{ color: var(--muted); margin: 0 0 12px 0; }

    .controls{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items:center;
      margin-bottom: 10px;
    }

    label{ font-size: 14px; }
    input[type="text"]{
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 14px;
      background: #fff;
      min-width: 240px;
    }

    button{
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.25);
      font-size: 16px;
      cursor: pointer;
      background: #fff;
    }
    button.primary{
      background: #2e7d32;
      color: #fff;
      border-color: rgba(0,0,0,0.2);
    }
    button.secondary{
      background: #5b6066;
      color: #fff;
      border-color: rgba(0,0,0,0.2);
    }

    select{
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 14px;
      background: #fff;
      min-width: 260px;
    }

    .statusBar{
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 10px;
      border: 2px solid rgba(46,125,50,0.25);
      background: rgba(46,125,50,0.08);
      margin: 10px 0 12px 0;
      font-weight: 600;
    }
    .statusDot{
      width: 12px;
      height: 12px;
      border-radius: 999px;
      display:inline-block;
      margin-right: 10px;
      background: #2e7d32;
    }
    .statusDot.off{
      background: #d32f2f;
    }
    .statusLeft{
      display:flex;
      align-items:center;
      gap: 0;
      flex: 1;
    }
    .statusRight{
      font-weight: 700;
      color: #2e7d32;
    }
    .statusRight.off{
      color: #d32f2f;
    }

    .msg{
      margin: 8px 0 10px 0;
      font-weight: 700;
      color: #1b5e20;
    }
    .msg.err{
      color:#b71c1c;
    }

    /* Table */
    .tableWrap{
      overflow: auto;
      border: 3px solid var(--border);
      background: #fff;
    }

    table{
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
    }

    th, td{
      border: 3px solid var(--border);
      padding: 10px 10px;
      vertical-align: middle;
      background: #fff;
    }

    th{
      font-size: 18px;
      text-align: center;
      background: #e6e6e6;
    }

    /* Sticky first column */
    th.taskCol, td.taskCol{
      position: sticky;
      left: 0;
      z-index: 5;
      background: #fff;
      min-width: 260px;
      max-width: 320px;
      width: 280px;
    }
    /* Top-left sticky corner above task column */
    th.taskCol{
      z-index: 8;
    }

    /* Sticky header rows */
    thead th{
      position: sticky;
      top: 0;
      z-index: 7;
    }
    thead th.taskCol{
      z-index: 10;
    }

    /* Subheaders for Inc/Con/Refi row */
    .subhead{
      font-size: 16px;
      font-weight: 800;
    }

    /* Column backgrounds */
    .incBg{ background: var(--incCol); }
    .conBg{ background: var(--conCol); }
    .refiBg{ background: var(--refiCol); }

    /* Zone header row */
    .zoneRow td{
      font-weight: 900;
      font-size: 22px;
      line-height: 1.1;
    }
    .zoneMeta{
      font-size: 18px;
      font-weight: 800;
      color: #444;
      margin-top: 4px;
    }

    /* Info button */
    .infoBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 2px solid #111;
      font-weight: 900;
      margin-left: 10px;
      cursor: pointer;
      user-select:none;
      background:#fff;
      font-size: 16px;
      line-height: 1;
    }

    /* Mark squares */
    .markCell{
      text-align:center;
      min-width: 74px;
      width: 74px;
      padding: 10px 6px;
    }

    .square{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 42px;
      height: 42px;
      border-radius: 8px;
      border: 2px solid #9aa1a8;
      background: #e9ecef;
      font-size: 26px;
      font-weight: 900;
      line-height: 1;
      user-select:none;
      cursor:pointer;
    }

    /* Selected states (match column) */
    .square.on.inc{ background: var(--incOn); border-color: rgba(0,0,0,0.35); color: #fff; }
    .square.on.con{ background: var(--conOn); border-color: rgba(0,0,0,0.35); color: #111; }
    .square.on.refi{ background: var(--refiOn); border-color: rgba(0,0,0,0.35); color: #fff; }

    /* Smaller on phone */
    @media (max-width: 520px){
      th.taskCol, td.taskCol{
        min-width: 210px;
        max-width: 260px;
        width: 230px;
      }
      .markCell{
        min-width: 62px;
        width: 62px;
      }
      .square{
        width: 38px;
        height: 38px;
        font-size: 24px;
      }
      th{ font-size: 16px; }
      .zoneRow td{ font-size: 20px; }
    }

    /* Modal */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 9999;
    }
    .modal{
      width: min(680px, 100%);
      max-height: 80vh;
      overflow:auto;
      background: #fff;
      border-radius: 14px;
      border: 2px solid rgba(0,0,0,0.25);
      padding: 14px 14px 10px 14px;
    }
    .modalHead{
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 12px;
      margin-bottom: 8px;
    }
    .modalTitle{
      font-weight: 900;
      font-size: 18px;
    }
    .modalClose{
      cursor:pointer;
      border: 1px solid rgba(0,0,0,0.25);
      background: #f1f3f5;
      border-radius: 10px;
      padding: 8px 10px;
      font-weight: 800;
    }
    .modalBody{
      white-space: pre-wrap;
      font-size: 15px;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <p class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and synced to Supabase automatically when possible.
  </p>

  <div class="controls">
    <label>Group name:</label>
    <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />

    <label>Students:</label>
    <input id="studentsInput" type="text" placeholder="Example: 1 Albert, 2 Benedict, 3 Reuben OR Albert, Benedict, Reuben" />

    <button id="applyBtn" class="primary">Apply layout</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
    <button id="loadLocalBtn" class="primary">Load saved marks</button>

    <label>Saved groups:</label>
    <select id="savedGroupsSelect">
      <option value="">Select a saved group</option>
    </select>
    <button id="useGroupBtn" class="secondary">Use group</button>

    <button id="pullCloudBtn" class="secondary">Pull from cloud</button>
  </div>

  <div id="statusBar" class="statusBar">
    <div class="statusLeft">
      <span id="statusDot" class="statusDot"></span>
      <span id="statusText">Online: cloud is reachable.</span>
    </div>
    <div id="syncText" class="statusRight">Synced</div>
  </div>

  <div id="msg" class="msg"></div>

  <div class="tableWrap">
    <table id="grid"></table>
  </div>

  <div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <div id="modalTitle" class="modalTitle"></div>
        <button id="modalClose" class="modalClose">Close</button>
      </div>
      <div id="modalBody" class="modalBody"></div>
    </div>
  </div>

  <script>
    /***********************
     * Supabase config
     ***********************/
    const SUPABASE_URL = "YOUR_SUPABASE_URL";
    const SUPABASE_ANON_KEY = "YOUR_SUPABASE_ANON_KEY";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // IMPORTANT: column name in courses table
    // If you truly created it as "Participant_Map" (with capitals),
    // tell me and I will switch this to exact quoted usage.
    const COURSE_PARTICIPANT_MAP_COL = "participant_map";

    /***********************
     * Zone + tasks + info
     ***********************/
    const ZONES = [
      {
        zone: 1,
        title: "FLATS AND MAGIC CARPET AREA",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        infoTitle: "Zone 1",
        infoText:
`Possible Constraints
• Glide with reduced space or toward a target marker.
• Perform skating tasks with a variable snow surface (slightly packed or soft).
• Skating around obstacles (example: cones, stubbies).
• Use minor slope gradient to encourage longer glide or speed awareness.

Evaluation Focus
• Balance and coordination while gliding
• Smooth push and glide transitions
• Controlled direction and stopping
• Awareness of surrounding space and other riders`
      },
      {
        zone: 2,
        title: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        infoTitle: "Zone 2",
        infoText:
`Possible variations
• Perform a controlled stop during a sideslip or traverse.
• Link multiple turns with slight changes in snow texture or slope pitch.
• Ride both toe and heel sides in the same run.
• Follow a marked path or cone line to encourage directional awareness.

Evaluation Focus
• Smooth loading and unloading of the magic carpet
• Balanced posture while standing on both edges
• Controlled side slips without abrupt stops
• Stable traverses across the slope
• Linked turns showing direction and speed control`
      },
      {
        zone: 3,
        title: "FLAGGED GREEN RUN",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        infoTitle: "Zone 3",
        infoText:
`Evaluation Focus
• Continuous linked turns along the flagged path
• Speed managed through turn shape, not braking
• Controlled edge release and engagement
• Flow maintained through variable turn timing
• Adaptability to terrain, snow, and surrounding traffic`
      }
    ];

    const STATUSES = [
      { key: "Inc", css: "inc", bg: "incBg" },
      { key: "Con", css: "con", bg: "conBg" },
      { key: "Refi", css: "refi", bg: "refiBg" }
    ];

    /***********************
     * Local storage keys
     ***********************/
    const LS_GROUPS = "sb_assess_saved_groups_v3";     // list of group names
    const LS_DATA_PREFIX = "sb_assess_group_v3__";     // group data (students + marks)

    /***********************
     * DOM refs
     ***********************/
    const elGroupName = document.getElementById("groupName");
    const elStudentsInput = document.getElementById("studentsInput");
    const elApplyBtn = document.getElementById("applyBtn");
    const elExportBtn = document.getElementById("exportBtn");
    const elLoadLocalBtn = document.getElementById("loadLocalBtn");
    const elUseGroupBtn = document.getElementById("useGroupBtn");
    const elSavedGroupsSelect = document.getElementById("savedGroupsSelect");
    const elGrid = document.getElementById("grid");
    const elMsg = document.getElementById("msg");

    const elStatusDot = document.getElementById("statusDot");
    const elStatusText = document.getElementById("statusText");
    const elSyncText = document.getElementById("syncText");
    const elStatusBar = document.getElementById("statusBar");

    const elPullCloudBtn = document.getElementById("pullCloudBtn");

    const elModalOverlay = document.getElementById("modalOverlay");
    const elModalTitle = document.getElementById("modalTitle");
    const elModalBody = document.getElementById("modalBody");
    const elModalClose = document.getElementById("modalClose");

    /***********************
     * State
     ***********************/
    let currentGroup = "";
    let students = []; // array of display labels in correct order (what columns show)
    // marks[group][studentLabel][zone][task] = "Inc" | "Con" | "Refi"
    let marks = {};

    let cloudReachable = true;
    let isSyncing = false;

    /***********************
     * Helpers
     ***********************/
    function setMsg(text, isError=false){
      elMsg.textContent = text || "";
      elMsg.className = "msg" + (isError ? " err" : "");
    }

    function normalizeGroupName(name){
      return (name || "").trim();
    }

    function parseStudentsInput(raw){
      // Accept:
      // "1 Albert, 2 Benedict, 3 Reuben"
      // "Albert, Benedict, Reuben"
      // "1,2,3" (rare)
      const parts = raw.split(",").map(s => s.trim()).filter(Boolean);

      // Keep original order as typed for the visual columns.
      // The participant_map (cloud) controls order across devices.
      return parts;
    }

    function ensureGroupState(groupName){
      if (!marks[groupName]) marks[groupName] = {};
      for (const s of students){
        if (!marks[groupName][s]) marks[groupName][s] = {};
      }
    }

    function lsGetGroups(){
      try{
        return JSON.parse(localStorage.getItem(LS_GROUPS) || "[]");
      }catch{
        return [];
      }
    }

    function lsSaveGroups(list){
      localStorage.setItem(LS_GROUPS, JSON.stringify(list));
    }

    function lsSaveGroupData(groupName){
      const key = LS_DATA_PREFIX + groupName;
      const payload = {
        group: groupName,
        students,
        marks: marks[groupName] || {}
      };
      localStorage.setItem(key, JSON.stringify(payload));

      // also ensure group is in saved list
      const list = lsGetGroups();
      if (!list.includes(groupName)){
        list.push(groupName);
        lsSaveGroups(list);
      }
      refreshSavedGroupsDropdown();
    }

    function lsLoadGroupData(groupName){
      const key = LS_DATA_PREFIX + groupName;
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      try{
        return JSON.parse(raw);
      }catch{
        return null;
      }
    }

    function refreshSavedGroupsDropdown(){
      const list = lsGetGroups();
      const selected = elSavedGroupsSelect.value;
      elSavedGroupsSelect.innerHTML = `<option value="">Select a saved group</option>`;
      for (const g of list){
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = g;
        elSavedGroupsSelect.appendChild(opt);
      }
      if (selected) elSavedGroupsSelect.value = selected;
    }

    function openModal(title, body){
      elModalTitle.textContent = title;
      elModalBody.textContent = body;
      elModalOverlay.style.display = "flex";
    }
    function closeModal(){
      elModalOverlay.style.display = "none";
    }

    function updateOnlineUI(isOnline){
      cloudReachable = isOnline;
      if (isOnline){
        elStatusDot.classList.remove("off");
        elStatusText.textContent = "Online: cloud is reachable.";
        elStatusBar.style.borderColor = "rgba(46,125,50,0.25)";
        elStatusBar.style.background = "rgba(46,125,50,0.08)";
        elSyncText.classList.remove("off");
      }else{
        elStatusDot.classList.add("off");
        elStatusText.textContent = "Offline: using local storage.";
        elStatusBar.style.borderColor = "rgba(211,47,47,0.25)";
        elStatusBar.style.background = "rgba(211,47,47,0.08)";
        elSyncText.classList.add("off");
      }
    }

    async function pingCloud(){
      try{
        // lightweight query to verify auth + reachability
        const { error } = await supabaseClient.from("courses").select("group_name").limit(1);
        updateOnlineUI(!error);
      }catch{
        updateOnlineUI(false);
      }
    }

    /***********************
     * Cloud: participant_map
     ***********************/
    function buildParticipantMap(studentsList){
      // Students are whatever the instructor typed. We store a stable ordering map.
      // If the instructor typed "2 Reuben", store orderKey: 2, label: "2 Reuben"
      // If name only, orderKey: null and preserve typed order.
      const map = studentsList.map((label, idx) => {
        const m = label.match(/^(\d+)\s+(.+)$/);
        if (m){
          return { label, bib: Number(m[1]), name: m[2], order: Number(m[1]) };
        }
        return { label, bib: null, name: label, order: 1000000 + idx };
      });

      // Sort by order so bib numbers become consistent across devices.
      map.sort((a,b) => a.order - b.order);
      return map;
    }

    async function ensureCourseRow(groupName){
      // Upsert into courses table with participant map.
      const pmap = buildParticipantMap(students);

      const payload = {
        group_name: groupName,
        is_closed: false,
        [COURSE_PARTICIPANT_MAP_COL]: pmap
      };

      // Insert if missing, otherwise update participant map.
      // This requires you have INSERT/UPDATE policies on courses for anon.
      const { error } = await supabaseClient
        .from("courses")
        .upsert(payload, { onConflict: "group_name" });

      if (error) throw error;
    }

    async function fetchCourseRow(groupName){
      const { data, error } = await supabaseClient
        .from("courses")
        .select(`group_name, is_closed, ${COURSE_PARTICIPANT_MAP_COL}`)
        .eq("group_name", groupName)
        .maybeSingle();

      if (error) throw error;
      return data;
    }

    /***********************
     * Cloud: evaluations UPSERT
     ***********************/
    async function upsertEvaluation(groupName, studentLabel, zoneNum, taskName, statusKey){
      // This is the critical fix. It triggers POST with onConflict and updates the row.
      const row = {
        group_name: groupName,
        student: studentLabel,
        zone: zoneNum,
        task: taskName,
        status: statusKey
      };

      const { error } = await supabaseClient
        .from("evaluations")
        .upsert(row, { onConflict: "group_name,student,zone,task" });

      if (error) throw error;
    }

    async function deleteEvaluation(groupName, studentLabel, zoneNum, taskName){
      const { error } = await supabaseClient
        .from("evaluations")
        .delete()
        .eq("group_name", groupName)
        .eq("student", studentLabel)
        .eq("zone", zoneNum)
        .eq("task", taskName);

      if (error) throw error;
    }

    async function pullEvaluationsFromCloud(groupName){
      const { data, error } = await supabaseClient
        .from("evaluations")
        .select("group_name,student,zone,task,status")
        .eq("group_name", groupName);

      if (error) throw error;
      return data || [];
    }

    /***********************
     * Rendering
     ***********************/
    function buildGrid(){
      if (!currentGroup || students.length === 0){
        elGrid.innerHTML = "";
        return;
      }

      ensureGroupState(currentGroup);

      // Header rows:
      // Row 1: Task | Student | Student | Student ...
      // Row 2: blank under Task | Inc Con Refi | Inc Con Refi ...
      const thead = document.createElement("thead");

      const r1 = document.createElement("tr");
      const thTask = document.createElement("th");
      thTask.className = "taskCol";
      thTask.textContent = "Task";
      r1.appendChild(thTask);

      for (const s of students){
        const th = document.createElement("th");
        th.colSpan = 3;
        th.textContent = s;
        r1.appendChild(th);
      }
      thead.appendChild(r1);

      const r2 = document.createElement("tr");
      const thBlank = document.createElement("th");
      thBlank.className = "taskCol";
      thBlank.textContent = "";
      r2.appendChild(thBlank);

      for (let i=0; i<students.length; i++){
        for (const st of STATUSES){
          const th = document.createElement("th");
          th.className = "subhead " + st.bg;
          th.textContent = st.key;
          r2.appendChild(th);
        }
      }
      thead.appendChild(r2);

      const tbody = document.createElement("tbody");

      for (const z of ZONES){
        // Zone row
        const zr = document.createElement("tr");
        zr.className = "zoneRow";

        const tdZ = document.createElement("td");
        tdZ.className = "taskCol";
        tdZ.innerHTML = `
          <div>
            <div>Zone ${z.zone} <span class="infoBtn" data-zone="${z.zone}">i</span></div>
            <div class="zoneMeta">${z.title}</div>
          </div>
        `;
        zr.appendChild(tdZ);

        for (const s of students){
          const td = document.createElement("td");
          td.colSpan = 3;
          td.style.textAlign = "center";
          td.style.fontWeight = "900";
          td.style.background = z.zone === 1 ? "#dfefff" : (z.zone === 2 ? "#e7f5ea" : "#f3eddc");
          td.textContent = s;
          zr.appendChild(td);
        }
        tbody.appendChild(zr);

        // Task rows
        for (const taskName of z.tasks){
          const tr = document.createElement("tr");

          const tdTask = document.createElement("td");
          tdTask.className = "taskCol";
          tdTask.textContent = taskName;
          tr.appendChild(tdTask);

          for (const s of students){
            const current = (((marks[currentGroup] || {})[s] || {})[z.zone] || {})[taskName] || "";

            for (const st of STATUSES){
              const td = document.createElement("td");
              td.className = "markCell " + st.bg;

              const sq = document.createElement("div");
              sq.className = "square " + st.css;
              sq.dataset.group = currentGroup;
              sq.dataset.student = s;
              sq.dataset.zone = String(z.zone);
              sq.dataset.task = taskName;
              sq.dataset.status = st.key;

              if (current === st.key){
                sq.classList.add("on", st.css);
                sq.textContent = "✓";
              }else{
                sq.textContent = "";
              }

              td.appendChild(sq);
              tr.appendChild(td);
            }
          }

          tbody.appendChild(tr);
        }
      }

      elGrid.innerHTML = "";
      elGrid.appendChild(thead);
      elGrid.appendChild(tbody);

      // Hook info buttons
      elGrid.querySelectorAll(".infoBtn").forEach(btn => {
        btn.addEventListener("click", () => {
          const zoneNum = Number(btn.dataset.zone);
          const z = ZONES.find(x => x.zone === zoneNum);
          if (!z) return;
          openModal(`${z.infoTitle}: ${z.title}`, z.infoText);
        });
      });
    }

    function setMarkLocal(groupName, studentLabel, zoneNum, taskName, statusKey){
      if (!marks[groupName]) marks[groupName] = {};
      if (!marks[groupName][studentLabel]) marks[groupName][studentLabel] = {};
      if (!marks[groupName][studentLabel][zoneNum]) marks[groupName][studentLabel][zoneNum] = {};
      marks[groupName][studentLabel][zoneNum][taskName] = statusKey;
      lsSaveGroupData(groupName);
    }

    function clearMarkLocal(groupName, studentLabel, zoneNum, taskName){
      try{
        delete marks[groupName][studentLabel][zoneNum][taskName];
      }catch{}
      lsSaveGroupData(groupName);
    }

    function rerenderRowSquares(studentLabel, zoneNum, taskName){
      // Update just the 3 squares for this student/task/zone.
      // Simpler: rebuild whole table, still fast enough for these sizes.
      buildGrid();
    }

    /***********************
     * Sync logic
     ***********************/
    async function trySyncMark(groupName, studentLabel, zoneNum, taskName, statusKey){
      if (!cloudReachable) return;

      isSyncing = true;
      elSyncText.textContent = "Syncing...";
      try{
        await upsertEvaluation(groupName, studentLabel, zoneNum, taskName, statusKey);
        elSyncText.textContent = "Synced";
      }catch (e){
        elSyncText.textContent = "Not synced";
        updateOnlineUI(false);
      }finally{
        isSyncing = false;
      }
    }

    async function tryDeleteMark(groupName, studentLabel, zoneNum, taskName){
      if (!cloudReachable) return;

      isSyncing = true;
      elSyncText.textContent = "Syncing...";
      try{
        await deleteEvaluation(groupName, studentLabel, zoneNum, taskName);
        elSyncText.textContent = "Synced";
      }catch (e){
        elSyncText.textContent = "Not synced";
        updateOnlineUI(false);
      }finally{
        isSyncing = false;
      }
    }

    /***********************
     * Event handlers
     ***********************/
    elApplyBtn.addEventListener("click", async () => {
      setMsg("");

      const g = normalizeGroupName(elGroupName.value);
      if (!g){
        setMsg("Please enter a group name.", true);
        return;
      }
      const sList = parseStudentsInput(elStudentsInput.value);
      if (sList.length === 0){
        setMsg("Please enter at least one student (comma-separated).", true);
        return;
      }

      currentGroup = g;
      students = sList;

      // Ensure local
      ensureGroupState(currentGroup);
      lsSaveGroupData(currentGroup);

      // Build UI immediately
      buildGrid();

      // Try cloud: save course row with participant map
      try{
        await pingCloud();
        if (cloudReachable){
          await ensureCourseRow(currentGroup);
          setMsg("Layout saved locally and synced to cloud.");
        }else{
          setMsg("Saved locally. Cloud not reachable.", false);
        }
      }catch (e){
        setMsg("Saved locally. Cloud sync failed.", false);
      }
    });

    elLoadLocalBtn.addEventListener("click", () => {
      setMsg("");
      const g = normalizeGroupName(elGroupName.value);
      if (!g){
        setMsg("Enter the group name you want to load.", true);
        return;
      }
      const data = lsLoadGroupData(g);
      if (!data){
        setMsg("No local data found for that group.", true);
        return;
      }
      currentGroup = data.group;
      students = data.students || [];
      marks[currentGroup] = data.marks || {};
      buildGrid();
      setMsg("Loaded. Local marks kept where present.");
    });

    elUseGroupBtn.addEventListener("click", () => {
      setMsg("");
      const g = elSavedGroupsSelect.value;
      if (!g){
        setMsg("Select a saved group first.", true);
        return;
      }
      const data = lsLoadGroupData(g);
      if (!data){
        setMsg("No local data found for that group.", true);
        return;
      }
      elGroupName.value = g;
      currentGroup = data.group;
      students = data.students || [];
      marks[currentGroup] = data.marks || {};
      buildGrid();
      setMsg("Loaded group from local storage.");
    });

    elPullCloudBtn.addEventListener("click", async () => {
      setMsg("");
      const g = normalizeGroupName(elGroupName.value);
      if (!g){
        setMsg("Enter the group name to pull from the cloud.", true);
        return;
      }

      try{
        await pingCloud();
        if (!cloudReachable){
          setMsg("Cloud is not reachable. Try again when online.", true);
          return;
        }

        // Get course row so we can apply participant_map ordering across devices
        const course = await fetchCourseRow(g);
        if (!course){
          setMsg("Group not found in cloud courses table.", true);
          return;
        }

        const pmap = course[COURSE_PARTICIPANT_MAP_COL] || [];
        if (Array.isArray(pmap) && pmap.length){
          // Use stored stable order
          students = pmap.map(x => x.label).filter(Boolean);
        }else{
          // fallback: keep what user typed
          students = parseStudentsInput(elStudentsInput.value);
        }

        currentGroup = g;
        ensureGroupState(currentGroup);

        const rows = await pullEvaluationsFromCloud(g);

        // Convert to local marks shape
        if (!marks[currentGroup]) marks[currentGroup] = {};
        for (const s of students){
          if (!marks[currentGroup][s]) marks[currentGroup][s] = {};
        }

        for (const r of rows){
          const s = r.student;
          const z = Number(r.zone);
          const t = r.task;
          const status = r.status || "";
          if (!marks[currentGroup][s]) marks[currentGroup][s] = {};
          if (!marks[currentGroup][s][z]) marks[currentGroup][s][z] = {};
          if (status){
            marks[currentGroup][s][z][t] = status;
          }
        }

        // Save local and render
        lsSaveGroupData(currentGroup);
        buildGrid();
        setMsg("Pulled from cloud and saved locally.");
      }catch (e){
        setMsg("Failed to pull from cloud.", true);
      }
    });

    // Grid click handler (delegated)
    elGrid.addEventListener("click", async (ev) => {
      const target = ev.target;
      if (!(target instanceof HTMLElement)) return;
      if (!target.classList.contains("square")) return;

      const g = target.dataset.group;
      const s = target.dataset.student;
      const z = Number(target.dataset.zone);
      const t = target.dataset.task;
      const status = target.dataset.status;

      // Determine current for that student/task/zone
      const current = (((marks[g] || {})[s] || {})[z] || {})[t] || "";

      // Clicking a status sets it, clicking again clears it
      if (current === status){
        clearMarkLocal(g, s, z, t);
        rerenderRowSquares(s, z, t);
        await tryDeleteMark(g, s, z, t);
      }else{
        setMarkLocal(g, s, z, t, status);
        rerenderRowSquares(s, z, t);
        await trySyncMark(g, s, z, t, status);
      }
    });

    elExportBtn.addEventListener("click", () => {
      if (!currentGroup || students.length === 0){
        setMsg("Create or load a group first.", true);
        return;
      }
      const rows = [];
      rows.push(["group_name","student","zone","task","status"].join(","));

      for (const s of students){
        for (const z of ZONES){
          for (const taskName of z.tasks){
            const status = (((marks[currentGroup] || {})[s] || {})[z.zone] || {})[taskName] || "";
            rows.push([currentGroup, s, z.zone, `"${taskName.replace(/"/g,'""')}"`, status].join(","));
          }
        }
      }

      const csv = rows.join("\n");
      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `${currentGroup.replace(/\s+/g,"_")}_assessments.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setMsg("CSV exported.");
    });

    elModalClose.addEventListener("click", closeModal);
    elModalOverlay.addEventListener("click", (e) => {
      if (e.target === elModalOverlay) closeModal();
    });

    /***********************
     * Init
     ***********************/
    refreshSavedGroupsDropdown();
    pingCloud();
    window.addEventListener("online", pingCloud);
    window.addEventListener("offline", () => updateOnlineUI(false));
  </script>
</body>
</html>