<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment Grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: #f4f6f8;
    }

    h1 { margin-bottom: 4px; }

    .small {
      font-size: 0.85rem;
      color: #555;
    }

    .controls {
      margin: 12px 0 20px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label { font-size: 0.9rem; }

    input[type="text"], select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 0.9rem;
    }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color: white;
      cursor: pointer;
      font-size: 0.9rem;
    }

    button.secondary {
      background: #5b636a;
      border-color: #4a5056;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    /* Connection status banner */
    #connectionStatus {
      margin: 10px 0 10px 0;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      background: #ffffff;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #connectionStatus .left {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    #connectionStatus .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex: 0 0 auto;
      border: 1px solid rgba(0,0,0,0.2);
    }

    #connectionStatus .text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #connectionStatus .right {
      flex: 0 0 auto;
      font-size: 0.85rem;
      color: #555;
      white-space: nowrap;
    }

    #connectionStatus.online .dot { background: #2e7d32; }
    #connectionStatus.online { border-color: #b7dfc2; background: #f1fbf3; }

    #connectionStatus.offline .dot { background: #616161; }
    #connectionStatus.offline { border-color: #d0d0d0; background: #f6f6f6; }

    /* Horizontal scroll wrapper */
    #tableContainer {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch; /* IMPORTANT for iOS */
    }

    table {
      border-collapse: collapse;
      width: 100%;
      background: white;
      min-width: 700px;
    }

    th, td {
      border: 2px solid #000;
      padding: 6px 4px;
      text-align: center;
      font-size: 0.85rem;
    }

    /* Sticky first column for task names */
    th.task-col,
    td.task-col {
      text-align: left;
      min-width: 70px;
      max-width: 85px;
      background: #f9fbfd;
      position: sticky;
      left: 0;
      z-index: 3;
      white-space: normal;
      word-break: break-word;
      padding-left: 4px;
      padding-right: 4px;
      font-size: inherit;
      line-height: 1.1;
    }

    th.zone-header {
      text-align: left;
      font-size: 0.95rem;
    }

    th.student-group-header {
      background: #d9dde0;
    }

    th.status-header {
      font-size: 0.75rem;
    }

    /* Zone row background colors */
    .zone-row-1 th { background: #e3f2fd; }
    .zone-row-2 th { background: #e8f5e9; }
    .zone-row-3 th { background: #fff3e0; }

    .status-cell { background: #f5f5f5; }

    .status-inner {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #e9ecef;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .status-inner.selected::after {
      content: "âœ“";
      color: white;
      font-size: 0.8rem;
    }

    /* Inc = red */
    .status-header[data-status="Inc"],
    .status-cell[data-status="Inc"] { background: #ffebee; }

    .status-inner[data-status="Inc"].selected {
      background: #c62828;
      border-color: #8e0000;
    }

    /* Con = yellow */
    .status-header[data-status="Con"],
    .status-cell[data-status="Con"] { background: #fffde7; }

    .status-inner[data-status="Con"].selected {
      background: #f9a825;
      border-color: #c17900;
    }

    /* Refi = green */
    .status-header[data-status="Refi"],
    .status-cell[data-status="Refi"] { background: #e8f5e9; }

    .status-inner[data-status="Refi"].selected {
      background: #2e7d32;
      border-color: #1b5e20;
    }

    .message {
      margin-top: 8px;
      font-size: 0.8rem;
      color: #444;
    }

    .error { color: #b00020; }
    .success { color: #1b5e20; }

    @media (max-width: 600px) {
      th.task-col,
      td.task-col {
        min-width: 95px;
        max-width: 115px;
        font-size: 0.72rem;
        line-height: 1.15;
      }
      table { font-size: 0.75rem; }
      th, td { padding: 4px 2px; }
      .status-inner { width: 26px; height: 26px; }
    }

    @media (pointer: coarse) {
      .status-inner { width: 30px; height: 30px; }
      th, td { padding-top: 6px; padding-bottom: 6px; }
    }
  </style>
</head>
<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and
    synced to Supabase automatically when online. You can also export to CSV.
  </div>

  <div class="controls">
    <label>
      Group name:
      <input id="groupNameInput" type="text" placeholder="e.g. Lake Louise Group A" />
    </label>

    <label>
      Students:
      <input id="studentsInput" type="text" value="Reuben, Albert, Benedict" />
    </label>

    <button id="applyLayoutBtn">Apply layout</button>
    <button id="loadBtn">Load saved marks</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
  </div>

  <div class="controls">
    <label>
      Saved groups:
      <select id="groupSelect">
        <option value="">Select a saved group</option>
      </select>
    </label>
    <button id="useGroupBtn" class="secondary">Use group</button>
  </div>

  <div id="connectionStatus" class="offline" aria-live="polite">
    <div class="left">
      <span class="dot" aria-hidden="true"></span>
      <div class="text" id="connectionText">Offline: changes saved on this device.</div>
    </div>
    <div class="right" id="connectionRight">Not synced</div>
  </div>

  <div id="statusMsg" class="message"></div>
  <div id="tableContainer"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const STATUSES = ["Inc", "Con", "Refi"];

    const TASKS = [
      { zone: 1, label: "Load and unload a chairlift and Riding the magic carpet" },
      { zone: 1, label: "Skating in a straight line" },
      { zone: 1, label: "Skate around cones" },
      { zone: 1, label: "Skate across a slope on both edges" },
      { zone: 1, label: "Switch skating in straight line" },
      { zone: 1, label: "J-turns" },

      { zone: 2, label: "Stand up on both edges" },
      { zone: 2, label: "Sideslip both edges" },
      { zone: 2, label: "Traversing on both edges" },
      { zone: 2, label: "Turning edge to edge down fall line (Linked turns)" },

      { zone: 3, label: "Linked Turns (Continuous)" },
      { zone: 3, label: "Speed Control Through Turn Shape" },
      { zone: 3, label: "Edge Release and Engagement" },
      { zone: 3, label: "Flow and Continuity" },
      { zone: 3, label: "Adaptability" }
    ];

    const groupNameInput = document.getElementById("groupNameInput");
    const studentsInput = document.getElementById("studentsInput");
    const tableContainer = document.getElementById("tableContainer");
    const statusMsg = document.getElementById("statusMsg");
    const exportBtn = document.getElementById("exportBtn");
    const groupSelect = document.getElementById("groupSelect");
    const useGroupBtn = document.getElementById("useGroupBtn");

    const connectionStatusEl = document.getElementById("connectionStatus");
    const connectionTextEl = document.getElementById("connectionText");
    const connectionRightEl = document.getElementById("connectionRight");

    let currentStudents = [];

    const LOCAL_STATE_PREFIX = "assessmentGrid_state_";
    const LOCAL_QUEUE_KEY = "assessmentGrid_queue_v1";
    const LOCAL_GROUPS_KEY = "assessmentGrid_groups";
    const LOCAL_ROSTER_PREFIX = "assessmentGrid_roster_"; // NEW

    document.getElementById("applyLayoutBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();

      if (!groupName) {
        setMessage("Enter a group name first.", true);
        return;
      }
      if (currentStudents.length === 0) {
        setMessage("Enter at least one student.", true);
        return;
      }

      saveRoster(groupName, currentStudents); // NEW
      renderTable();
      clearMessage();
      registerGroupName(groupName);
      applyLocalStateToUI(groupName);

      // iOS: force a reflow after table exists
      requestAnimationFrame(() => forceTableReflow());
      updateConnectionStatusUI();
    });

    document.getElementById("loadBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();

      if (groupName && currentStudents.length > 0) {
        saveRoster(groupName, currentStudents); // NEW
      }

      renderTable();
      registerGroupName(groupName);
      loadSavedMarks();

      requestAnimationFrame(() => forceTableReflow());
      updateConnectionStatusUI();
    });

    exportBtn.addEventListener("click", exportCurrentGroupToCSV);

    useGroupBtn.addEventListener("click", () => {
      const selectedGroup = groupSelect.value;
      if (!selectedGroup) {
        setMessage("Select a saved group first.", true);
        return;
      }

      groupNameInput.value = selectedGroup;

      // NEW: pull roster first, then fall back to marks
      const roster = loadRoster(selectedGroup);
      if (roster.length > 0) {
        studentsInput.value = roster.join(", ");
      } else {
        setStudentsFromLocalState(selectedGroup);
      }

      currentStudents = parseStudents();
      renderTable();
      loadSavedMarks();

      requestAnimationFrame(() => forceTableReflow());
      updateConnectionStatusUI();
    });

    function parseStudents() {
      return studentsInput.value
        .split(",")
        .map(s => s.trim())
        .filter(s => s.length > 0);
    }

    function clearMessage() {
      statusMsg.textContent = "";
      statusMsg.className = "message";
    }

    function setMessage(text, isError = false) {
      statusMsg.textContent = text;
      statusMsg.className = "message " + (isError ? "error" : "success");
    }

    // NEW: roster persistence
    function saveRoster(groupName, students) {
      try {
        localStorage.setItem(LOCAL_ROSTER_PREFIX + groupName, JSON.stringify(students));
      } catch {}
    }

    function loadRoster(groupName) {
      try {
        const raw = localStorage.getItem(LOCAL_ROSTER_PREFIX + groupName);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed.filter(s => typeof s === "string" && s.trim().length > 0) : [];
      } catch {
        return [];
      }
    }

    // NEW: iOS Safari reflow helper
    function forceTableReflow() {
      const el = tableContainer;
      if (!el) return;

      // trigger layout without changing content
      el.scrollLeft = 0;
      const prev = el.style.transform;
      el.style.transform = "translateZ(0)";
      // read a layout property to force reflow
      void el.offsetHeight;
      el.style.transform = prev || "";

      // One more tick can help after restore
      requestAnimationFrame(() => {
        void el.offsetHeight;
      });
    }

    function getQueueCount() {
      const q = loadQueue();
      return Array.isArray(q) ? q.length : 0;
    }

    function updateConnectionStatusUI(customRightText) {
      const online = navigator.onLine;
      const queueCount = getQueueCount();

      connectionStatusEl.classList.toggle("online", online);
      connectionStatusEl.classList.toggle("offline", !online);

      connectionTextEl.textContent = online
        ? "Online: syncing to cloud when changes are made."
        : "Offline: changes saved on this device.";

      if (typeof customRightText === "string") {
        connectionRightEl.textContent = customRightText;
        return;
      }

      if (!online) {
        connectionRightEl.textContent = queueCount > 0 ? ("Queued: " + queueCount) : "Not synced";
      } else {
        connectionRightEl.textContent = queueCount > 0 ? ("Pending sync: " + queueCount) : "Synced";
      }
    }

    // Group list helpers (local)
    function loadGroupList() {
      try {
        const raw = localStorage.getItem(LOCAL_GROUPS_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch {
        return [];
      }
    }

    function saveGroupList(list) {
      try {
        localStorage.setItem(LOCAL_GROUPS_KEY, JSON.stringify(list));
      } catch {}
    }

    function registerGroupName(groupName) {
      if (!groupName) return;
      const list = loadGroupList();
      if (!list.includes(groupName)) {
        list.push(groupName);
        saveGroupList(list);
        refreshGroupSelectOptions();
      }
    }

    async function refreshGroupSelectOptions() {
      const localGroups = loadGroupList();

      let evalGroups = [];
      let courseRows = [];

      if (navigator.onLine) {
        try {
          const { data: evalData, error: evalError } = await supabaseClient
            .from("evaluations")
            .select("group_name");
          if (!evalError && evalData) {
            evalGroups = evalData
              .map(row => row.group_name)
              .filter(name => typeof name === "string" && name.trim().length > 0);
          } else if (evalError) {
            console.error("Could not fetch evaluation group names", evalError);
          }

          const { data: courseData, error: courseError } = await supabaseClient
            .from("courses")
            .select("group_name,is_closed");
          if (!courseError && courseData) {
            courseRows = courseData;
          } else if (courseError) {
            console.error("Could not fetch courses", courseError);
          }
        } catch (e) {
          console.error("Error fetching group names from Supabase", e);
        }
      }

      const closedGroups = new Set(
        courseRows
          .filter(row => row.is_closed)
          .map(row => row.group_name)
      );

      const openCourses = courseRows
        .filter(row => !row.is_closed)
        .map(row => row.group_name);

      const openCloudGroupsSet = new Set();
      evalGroups.forEach(name => {
        if (!closedGroups.has(name)) {
          openCloudGroupsSet.add(name);
        }
      });
      openCourses.forEach(name => openCloudGroupsSet.add(name));

      const mergedSet = new Set();

      localGroups.forEach(name => {
        if (!closedGroups.has(name)) {
          mergedSet.add(name);
        }
      });

      openCloudGroupsSet.forEach(name => mergedSet.add(name));

      const mergedList = Array.from(mergedSet).sort((a, b) => a.localeCompare(b));

      saveGroupList(mergedList);

      while (groupSelect.options.length > 1) groupSelect.remove(1);
      mergedList.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        groupSelect.appendChild(opt);
      });
    }

    function setStudentsFromLocalState(groupName) {
      const state = loadGroupState(groupName);
      const studentsSet = new Set();
      Object.keys(state).forEach(key => {
        const [student] = key.split("|");
        if (student) studentsSet.add(student);
      });
      if (studentsSet.size > 0) {
        studentsInput.value = Array.from(studentsSet).join(", ");
      }
    }

    // Local state helpers
    function localKey(student, zone, task) {
      return `${student}|${zone}|${task}`;
    }

    function loadGroupState(groupName) {
      if (!groupName) return {};
      try {
        const raw = localStorage.getItem(LOCAL_STATE_PREFIX + groupName);
        return raw ? JSON.parse(raw) : {};
      } catch {
        return {};
      }
    }

    function saveGroupState(groupName, state) {
      if (!groupName) return;
      try {
        localStorage.setItem(LOCAL_STATE_PREFIX + groupName, JSON.stringify(state));
      } catch {}
    }

    function updateLocalState(groupName, student, zone, task, status) {
      if (!groupName) return;
      const key = localKey(student, zone, task);
      const state = loadGroupState(groupName);
      state[key] = status;
      saveGroupState(groupName, state);
      registerGroupName(groupName);

      // ensure roster exists even if user forgets to press Apply layout
      const roster = loadRoster(groupName);
      if (roster.length === 0) {
        const parsed = parseStudents();
        if (parsed.length > 0) saveRoster(groupName, parsed);
      }
    }

    function applyLocalStateToUI(groupName) {
      if (!groupName) return;
      const state = loadGroupState(groupName);

      Object.entries(state).forEach(([k, status]) => {
        const [student, zone, task] = k.split("|");
        const selectorAll =
          `.status-inner[data-student="${encodeURIComponent(student)}"]` +
          `[data-zone="${zone}"][data-task="${encodeURIComponent(task)}"]`;
        const selectorOne = selectorAll + `[data-status="${status}"]`;
        const cellToSelect = document.querySelector(selectorOne);
        if (!cellToSelect) return;
        document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
        cellToSelect.classList.add("selected");
      });
    }

    // Queue helpers
    function loadQueue() {
      try {
        const raw = localStorage.getItem(LOCAL_QUEUE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch {
        return [];
      }
    }

    function saveQueue(queue) {
      try {
        localStorage.setItem(LOCAL_QUEUE_KEY, JSON.stringify(queue));
      } catch {}
    }

    function enqueueOp(op) {
      let queue = loadQueue();
      queue = queue.filter(
        q =>
          !(
            q.group_name === op.group_name &&
            q.student === op.student &&
            q.zone === op.zone &&
            q.task === op.task
          )
      );
      queue.push(op);
      saveQueue(queue);
      registerGroupName(op.group_name);
      updateConnectionStatusUI();
    }

    async function trySaveToSupabase(op, isRetry = false) {
      if (!navigator.onLine) {
        enqueueOp(op);
        if (!isRetry) setMessage("Saved locally. No network, will sync when online.");
        updateConnectionStatusUI();
        return false;
      }

      try {
        const { error: delError } = await supabaseClient
          .from("evaluations")
          .delete()
          .eq("group_name", op.group_name)
          .eq("student", op.student)
          .eq("zone", op.zone)
          .eq("task", op.task);

        if (delError) throw delError;

        const { error: insError } = await supabaseClient.from("evaluations").insert(op);
        if (insError) throw insError;

        if (!isRetry) setMessage("Saved.");
        updateConnectionStatusUI();
        return true;
      } catch (e) {
        console.error("Supabase save failed", e);
        enqueueOp(op);
        if (!isRetry) {
          const msg = e && e.message ? e.message : String(e);
          setMessage("Saved locally, cloud error: " + msg, true);
        }
        updateConnectionStatusUI();
        return false;
      }
    }

    async function processQueue() {
      if (!navigator.onLine) {
        updateConnectionStatusUI();
        return;
      }

      let queue = loadQueue();
      if (queue.length === 0) {
        updateConnectionStatusUI();
        return;
      }

      const remaining = [];
      setMessage("Syncing offline changes...");
      updateConnectionStatusUI("Syncing...");

      for (const op of queue) {
        const ok = await trySaveToSupabase(op, true);
        if (!ok) remaining.push(op);
      }

      saveQueue(remaining);

      if (remaining.length === 0) {
        setMessage("Offline changes synced.");
      } else {
        setMessage("Some changes still saved locally. Will retry.", true);
      }

      updateConnectionStatusUI();
    }

    window.addEventListener("online", () => {
      updateConnectionStatusUI();
      processQueue();
      refreshGroupSelectOptions();
      requestAnimationFrame(() => forceTableReflow());
    });

    window.addEventListener("offline", () => {
      updateConnectionStatusUI();
      requestAnimationFrame(() => forceTableReflow());
    });

    // IMPORTANT for iOS Safari restore-from-cache
    window.addEventListener("pageshow", () => {
      // Re-render based on current inputs, then force layout
      currentStudents = parseStudents();
      if (currentStudents.length > 0 && groupNameInput.value.trim()) {
        renderTable();
        applyLocalStateToUI(groupNameInput.value.trim());
      }
      requestAnimationFrame(() => forceTableReflow());
      updateConnectionStatusUI();
    });

    window.addEventListener("orientationchange", () => {
      requestAnimationFrame(() => forceTableReflow());
    });

    window.addEventListener("resize", () => {
      requestAnimationFrame(() => forceTableReflow());
    });

    // Table rendering
    function renderTable() {
      const groupName = groupNameInput.value.trim();

      if (!groupName) {
        setMessage("Enter a group name first.", true);
        return;
      }

      if (currentStudents.length === 0) {
        setMessage("Enter at least one student.", true);
        return;
      }

      let html = "<table>";

      html += "<tr><th class='task-col'>Task</th>";
      currentStudents.forEach(student => {
        html += `<th class="student-group-header" colspan="${STATUSES.length}">${student}</th>`;
      });
      html += "</tr>";

      html += "<tr><th class='task-col'></th>";
      currentStudents.forEach(() => {
        STATUSES.forEach(status => {
          html += `<th class="status-header" data-status="${status}">${status}</th>`;
        });
      });
      html += "</tr>";

      let lastZone = null;

      TASKS.forEach(task => {
        if (task.zone !== lastZone) {
          html += `<tr class="zone-row zone-row-${task.zone}">`;
          html += `<th class="zone-header task-col">Zone ${task.zone}</th>`;
          currentStudents.forEach(student => {
            html += `<th class="zone-header student-group-header" colspan="${STATUSES.length}">
                       ${student}
                     </th>`;
          });
          html += "</tr>`;
          lastZone = task.zone;
        }

        html += `<tr><td class="task-col">${task.label}</td>`;

        currentStudents.forEach(student => {
          STATUSES.forEach(status => {
            html += `
              <td class="status-cell" data-status="${status}">
                <div class="status-inner"
                     data-student="${encodeURIComponent(student)}"
                     data-zone="${task.zone}"
                     data-task="${encodeURIComponent(task.label)}"
                     data-status="${status}">
                </div>
              </td>`;
          });
        });

        html += "</tr>";
      });

      html += "</table>";
      tableContainer.innerHTML = html;

      document.querySelectorAll(".status-inner").forEach(el => {
        el.addEventListener("click", onStatusClick);
      });
    }

    async function onStatusClick(event) {
      const el = event.currentTarget;
      const student = decodeURIComponent(el.dataset.student);
      const zone = parseInt(el.dataset.zone);
      const taskLabel = decodeURIComponent(el.dataset.task);
      const status = el.dataset.status;
      const groupName = groupNameInput.value.trim();

      if (!groupName) return;

      const selectorAll =
        `.status-inner[data-student="${encodeURIComponent(student)}"]` +
        `[data-zone="${zone}"][data-task="${encodeURIComponent(taskLabel)}"]`;

      document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
      el.classList.add("selected");

      updateLocalState(groupName, student, zone, taskLabel, status);

      const op = { group_name: groupName, student, zone, task: taskLabel, status };
      await trySaveToSupabase(op);

      updateConnectionStatusUI();
      requestAnimationFrame(() => forceTableReflow());
    }

    async function loadSavedMarks() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) return;

      registerGroupName(groupName);

      if (!navigator.onLine) {
        applyLocalStateToUI(groupName);
        setMessage("Offline: showing marks stored on this device.");
        updateConnectionStatusUI();
        requestAnimationFrame(() => forceTableReflow());
        return;
      }

      setMessage("Syncing and loading from Supabase...");
      updateConnectionStatusUI("Syncing...");

      await processQueue();

      const { data, error } = await supabaseClient
        .from("evaluations")
        .select("*")
        .eq("group_name", groupName);

      if (error) {
        console.error(error);
        setMessage("Failed to load from cloud. Keeping local marks.", true);
        applyLocalStateToUI(groupName);
        updateConnectionStatusUI();
        requestAnimationFrame(() => forceTableReflow());
        return;
      }

      const localState = loadGroupState(groupName);
      const mergedState = { ...localState };

      data.forEach(row => {
        const key = localKey(row.student, row.zone, row.task);
        if (mergedState[key] == null) mergedState[key] = row.status;
      });

      saveGroupState(groupName, mergedState);

      document.querySelectorAll(".status-inner").forEach(node => node.classList.remove("selected"));
      applyLocalStateToUI(groupName);

      setMessage("Loaded. Local marks kept where present.");
      updateConnectionStatusUI();
      requestAnimationFrame(() => forceTableReflow());
    }

    // CSV export
    function exportCurrentGroupToCSV() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) {
        setMessage("Enter a group name before exporting.", true);
        return;
      }

      const state = loadGroupState(groupName);
      const entries = Object.entries(state);
      if (entries.length === 0) {
        setMessage("No local marks found for this group to export.", true);
        return;
      }

      const headers = ["group_name", "student", "zone", "task", "status"];
      const lines = [headers.join(",")];

      entries.forEach(([key, status]) => {
        const [student, zone, task] = key.split("|");
        const rowObj = { group_name: groupName, student, zone, task, status };

        const values = headers.map(h => {
          let val = rowObj[h];
          if (val == null) val = "";
          val = String(val).replace(/"/g, '""');
          if (val.search(/[",\n]/) !== -1) val = '"' + val + '"';
          return val;
        });

        lines.push(values.join(","));
      });

      const csvContent = lines.join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = `snowboard_assessment_${groupName.replace(/\s+/g, "_")}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setMessage("CSV exported from local data.");
      updateConnectionStatusUI();
    }

    // Initial layout
    currentStudents = parseStudents();
    renderTable();
    refreshGroupSelectOptions();
    applyLocalStateToUI(groupNameInput.value.trim());
    processQueue();
    updateConnectionStatusUI();

    // initial reflow help (iOS)
    requestAnimationFrame(() => forceTableReflow());
  </script>
</body>
</html>
