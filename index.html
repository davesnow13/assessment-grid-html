<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snowboard Assessment Grid</title>

  <!-- Supabase JS v2 -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --bg:#f4f6f8;
      --border:#111;
      --muted:#555;

      --zone1:#dfeef9;
      --zone2:#e6f3e6;
      --zone3:#f6ecd8;

      --incCol:#fae6e6;
      --conCol:#fbf2cf;
      --refiCol:#e6f4e6;

      --btn:#2e7d32;
      --btnText:#fff;
      --btn2:#5b5f66;

      --cellW:56px;
      --taskMin:220px;
      --taskMax:420px;
    }

    body{
      margin:0;
      padding:16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background:var(--bg);
      color:#111;
    }

    h1{ margin:0 0 6px 0; font-size:34px; line-height:1.1; }
    .subtitle{ margin:0 0 14px 0; color:var(--muted); font-size:14px; }

    .controls{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-bottom:12px;
    }

    .row{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:flex-end;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    label{ font-size:14px; color:#111; font-weight:700; }

    input[type="text"], select{
      padding:8px 10px;
      border:1px solid #c9d1d9;
      border-radius:8px;
      font-size:14px;
      background:#fff;
      min-width:240px;
      max-width:100%;
    }

    button{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid #1b5e20;
      background:var(--btn);
      color:var(--btnText);
      font-weight:800;
      font-size:14px;
      cursor:pointer;
    }

    button.secondary{
      background:#fff;
      color:#111;
      border:1px solid #c9d1d9;
      font-weight:800;
    }

    button.gray{
      background:var(--btn2);
      border:1px solid #4b4f56;
      color:#fff;
    }

    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }

    .statusBar{
      display:flex;
      align-items:center;
      gap:10px;
      background:#eef7ee;
      border:1px solid #b7e0b7;
      border-radius:12px;
      padding:10px 12px;
      margin:10px 0 10px 0;
      font-weight:800;
    }
    .dot{
      width:12px; height:12px; border-radius:999px;
      background:#2e7d32;
      box-shadow: 0 0 0 3px rgba(46,125,50,.15);
    }
    .dot.offline{
      background:#b00020;
      box-shadow: 0 0 0 3px rgba(176,0,32,.15);
    }
    .statusRight{
      margin-left:auto;
      font-weight:900;
      color:#2e7d32;
    }
    .statusRight.offline{ color:#b00020; }

    .msg{
      margin:0 0 10px 0;
      font-weight:800;
      color:#2e7d32;
    }
    .msg.warn{ color:#b00020; }

    /* Table wrapper for horizontal scroll */
    .tableWrap{
      overflow:auto;
      border:3px solid var(--border);
      border-radius:12px;
      background:#fff;
      box-shadow: 0 4px 14px rgba(0,0,0,.06);
    }

    table{
      border-collapse:collapse;
      width:max-content;
      min-width:100%;
      table-layout:fixed;
      background:#fff;
    }

    th, td{
      border:3px solid var(--border);
      padding:10px;
      vertical-align:middle;
    }

    /* Sticky header */
    thead th{
      position:sticky;
      top:0;
      background:#fff;
      z-index:10;
    }

    /* Sticky first column (Task) */
    .taskHead,
    .taskCell,
    .zoneCell{
      position:sticky;
      left:0;
      background:#fff;
      z-index:30; /* keep above student headers while scrolling */
    }

    thead .taskHead{
      z-index:60; /* very top */
      background:#fff;
    }

    .studentHead{
      text-align:center;
      font-size:22px;
      font-weight:900;
      background:#eee;
      white-space:nowrap;
      padding:10px 8px;
    }

    .subHead{
      font-size:14px;
      font-weight:900;
      text-align:center;
      padding:8px 6px;
    }

    /* Task column sizing (desktop) */
    .taskHead{
      font-size:18px;
      font-weight:900;
      text-align:left;
      width: min(max(36vw, var(--taskMin)), var(--taskMax));
      min-width: var(--taskMin);
      max-width: var(--taskMax);
    }

    .taskCell{
      width: min(max(36vw, var(--taskMin)), var(--taskMax));
      min-width: var(--taskMin);
      max-width: var(--taskMax);
      font-size:20px;
      line-height:1.2;
    }

    /* Phone portrait: shrink Task column so students stay visible */
    @media (max-width: 520px){
      :root{ --cellW:52px; }
      .taskHead, .taskCell{
        width: min(max(26vw, 180px), 300px);
        min-width: 180px;
        max-width: 300px;
        font-size:18px;
      }
      h1{ font-size:30px; }
    }

    .zoneCell{
      font-size:24px;
      font-weight:900;
      line-height:1.05;
      padding:10px;
    }

    .zoneCell small{
      display:block;
      font-size:16px;
      font-weight:900;
      color:#333;
      margin-top:2px;
    }

    .zone1{ background:var(--zone1) !important; }
    .zone2{ background:var(--zone2) !important; }
    .zone3{ background:var(--zone3) !important; }

    .incCol{ background:var(--incCol); }
    .conCol{ background:var(--conCol); }
    .refiCol{ background:var(--refiCol); }

    .cell{
      width:var(--cellW);
      min-width:var(--cellW);
      max-width:var(--cellW);
      text-align:center;
      padding:8px;
    }

    /* Mark buttons */
    .mark-btn{
      width:46px;
      height:46px;
      border-radius:10px;
      border:2px solid #9aa4ad;
      background:#e9edf1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:26px;
      font-weight:1000;
      line-height:1;
      user-select:none;
      cursor:pointer;
    }

    /* Selected states match column meaning */
    .mark-btn.selected.inc  { background:#d32f2f; border-color:#b71c1c; color:#fff; }
    .mark-btn.selected.con  { background:#f9a825; border-color:#c17900; color:#111; }
    .mark-btn.selected.refi { background:#2e7d32; border-color:#1b5e20; color:#fff; }

    /* Info icon (lowercase i) */
    .infoBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:26px;
      height:26px;
      border-radius:999px;
      border:2px solid #111;
      background:#fff;
      margin-left:10px;
      cursor:pointer;
      user-select:none;
      font-weight:900;
      font-size:16px;
      line-height:1;
      flex:0 0 auto;
    }
    .infoBtn::before{
      content:"i";
      transform: translateY(-1px);
    }

    /* Modal */
    .modalBackdrop{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      z-index:9999;
    }
    .modal{
      width:min(720px, 100%);
      background:#fff;
      border-radius:14px;
      border:3px solid #111;
      padding:14px 14px 12px 14px;
      box-shadow:0 12px 30px rgba(0,0,0,.25);
    }
    .modal h2{
      margin:0 0 8px 0;
      font-size:20px;
    }
    .modal .content{
      font-size:15px;
      color:#111;
      line-height:1.35;
      white-space:pre-wrap;
    }
    .modal .actions{
      display:flex;
      justify-content:flex-end;
      margin-top:12px;
    }

    @media print{
      body{ background:#fff; padding:0; }
      .controls, .statusBar, .msg { display:none !important; }
      .tableWrap{ border:none; box-shadow:none; }
      thead th{ position:static; }
      .taskHead, .taskCell, .zoneCell{ position:static; }
      *{
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <p class="subtitle">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Saved locally first, then synced to Supabase when reachable.
  </p>

  <div class="controls">
    <div class="row">
      <div class="field">
        <label for="groupName">Group name</label>
        <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />
      </div>

      <div class="field">
        <label for="studentsInput">Students</label>
        <input id="studentsInput" type="text" placeholder="Example: 2 Reuben, 1 Albert, Benedict" />
      </div>

      <div class="field">
        <label for="sortMode">Sort students</label>
        <select id="sortMode">
          <option value="entered">Keep entered order</option>
          <option value="bib">Sort by bib number (if present)</option>
          <option value="name">Sort by name</option>
        </select>
      </div>

      <div class="field">
        <label>&nbsp;</label>
        <button id="applyBtn">Apply layout</button>
      </div>
    </div>

    <div class="row">
      <div class="field">
        <label for="savedGroups">Saved groups (local)</label>
        <select id="savedGroups">
          <option value="">Select a saved group</option>
        </select>
      </div>
      <div class="field">
        <label>&nbsp;</label>
        <button id="useGroupBtn" class="gray">Use group</button>
      </div>

      <div class="field">
        <label for="cloudGroups">Groups (cloud)</label>
        <select id="cloudGroups">
          <option value="">Select a cloud group</option>
        </select>
      </div>
      <div class="field">
        <label>&nbsp;</label>
        <button id="pullCloudBtn" class="secondary">Pull from cloud</button>
      </div>

      <div class="field">
        <label>&nbsp;</label>
        <button id="refreshCloudBtn" class="secondary">Refresh cloud list</button>
      </div>
    </div>

    <div class="row">
      <div class="field">
        <label>&nbsp;</label>
        <button id="loadLocalBtn" class="secondary">Load saved marks</button>
      </div>
      <div class="field">
        <label>&nbsp;</label>
        <button id="exportBtn" class="gray">Export CSV (this group)</button>
      </div>
    </div>
  </div>

  <div class="statusBar" id="statusBar">
    <span class="dot" id="onlineDot"></span>
    <span id="onlineText">Online: cloud is reachable.</span>
    <span class="statusRight" id="syncText">Synced</span>
  </div>

  <p class="msg" id="msg"></p>

  <div class="tableWrap" id="tableWrap" style="display:none;">
    <table id="gridTable"></table>
  </div>

  <!-- Modal -->
  <div class="modalBackdrop" id="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="modalTitle">Info</h2>
      <div class="content" id="modalContent"></div>
      <div class="actions">
        <button id="closeModalBtn" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <script>
    /**********************************************************************
     * SUPABASE CONFIG (paste your real values)
     **********************************************************************/
    const SUPABASE_URL = "PASTE_YOUR_SUPABASE_URL_HERE";
    const SUPABASE_ANON_KEY = "PASTE_YOUR_SUPABASE_ANON_KEY_HERE";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    /**********************************************************************
     * TABLE + COLUMN NAMES (must match Supabase exactly)
     **********************************************************************/
    const COURSES_TABLE = "courses";
    const EVAL_TABLE = "evaluations";

    // courses columns
    const COL_GROUP = "group_name";
    const COL_CLOSED = "is_closed";
    const COL_PARTICIPANT_MAP = "Participant_Map"; // <-- your new column name

    // evaluations columns
    const COL_STUDENT = "student";
    const COL_ZONE = "zone";
    const COL_TASK = "task";
    const COL_STATUS = "status";
    const COL_UPDATED = "updated_at";

    /**********************************************************************
     * ZONES + TASKS (updated)
     **********************************************************************/
    const ZONES = [
      {
        id: 1,
        title: "Zone 1",
        subtitle: "FLATS AND MAGIC CARPET AREA",
        className: "zone1",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        infoTitle: "Zone 1: Constraints and Evaluation Focus",
        infoText:
`Possible Constraints
• Glide with reduced space or toward a target marker.
• Perform skating tasks with a variable snow surface (slightly packed or soft).
• Skating around obstacles (example: cones, stubbies)
• Use minor slope gradient to encourage longer glide or speed awareness.

Evaluation Focus
• Balance and coordination while gliding
• Smooth push and glide transitions
• Controlled direction and stopping
• Awareness of surrounding space and other riders`
      },
      {
        id: 2,
        title: "Zone 2",
        subtitle: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        className: "zone2",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        infoTitle: "Zone 2: Variations and Evaluation Focus",
        infoText:
`Possible variations
• Perform a controlled stop during a sideslip or traverse.
• Link multiple turns with slight changes in snow texture or slope pitch.
• Ride both toe and heel sides in the same run.
• Follow a marked path or cone line to encourage directional awareness.

Evaluation Focus
• Smooth loading and unloading of the lift
• Balanced posture while standing on both edges
• Controlled side slips without abrupt stops
• Stable traverses across the slope
• Linked turns showing direction and speed control`
      },
      {
        id: 3,
        title: "Zone 3",
        subtitle: "FLAGGED GREEN RUN",
        className: "zone3",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        infoTitle: "Zone 3: Evaluation Focus",
        infoText:
`Evaluation Focus
• Continuous linked turns along the flagged path
• Speed managed through turn shape, not braking
• Controlled edge release and engagement
• Flow maintained through variable turn timing
• Adaptability to terrain, snow, and surrounding traffic`
      }
    ];

    /**********************************************************************
     * LOCAL STORAGE
     **********************************************************************/
    const LS_KEY = "sb_assessment_groups_v4";
    const LS_LAST_GROUP = "sb_assessment_last_group_v4";

    function nowIso(){ return new Date().toISOString(); }

    function loadAllLocal(){
      try{ return JSON.parse(localStorage.getItem(LS_KEY) || "{}"); }
      catch(e){ return {}; }
    }
    function saveAllLocal(obj){
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }

    function listLocalGroups(){
      return Object.keys(loadAllLocal()).sort((a,b)=>a.localeCompare(b));
    }

    function setMsg(text, warn=false){
      const el = document.getElementById("msg");
      el.textContent = text || "";
      el.classList.toggle("warn", !!warn);
    }

    /**********************************************************************
     * ONLINE / CLOUD REACHABILITY
     **********************************************************************/
    let cloudReachable = false;

    async function checkCloudReachable(){
      try{
        const { error } = await supabase.from(COURSES_TABLE).select(COL_GROUP).limit(1);
        cloudReachable = !error;
      }catch(e){
        cloudReachable = false;
      }
      updateOnlineUI();
    }

    function updateOnlineUI(){
      const dot = document.getElementById("onlineDot");
      const txt = document.getElementById("onlineText");
      const sync = document.getElementById("syncText");

      if(cloudReachable){
        dot.classList.remove("offline");
        txt.textContent = "Online: cloud is reachable.";
        sync.classList.remove("offline");
        sync.textContent = "Synced";
      }else{
        dot.classList.add("offline");
        txt.textContent = "Offline: showing marks stored on this device.";
        sync.classList.add("offline");
        sync.textContent = "Offline";
      }
    }

    /**********************************************************************
     * STUDENT PARSING + SORT
     **********************************************************************/
    function parseStudents(raw){
      const parts = (raw || "")
        .split(",")
        .map(s => s.trim())
        .filter(Boolean);

      const entries = [];
      for(const p of parts){
        // Name:2
        let m = p.match(/^(.+?)\s*[:=]\s*(\d+)$/);
        if(m){
          entries.push({ name: m[1].trim(), bib: parseInt(m[2],10) });
          continue;
        }
        // 2 Name
        m = p.match(/^(\d+)\s+(.+)$/);
        if(m){
          entries.push({ name: m[2].trim(), bib: parseInt(m[1],10) });
          continue;
        }
        // 2-Name or 2.Name
        m = p.match(/^(\d+)[\.\-]\s*(.+)$/);
        if(m){
          entries.push({ name: m[2].trim(), bib: parseInt(m[1],10) });
          continue;
        }
        entries.push({ name: p, bib: null });
      }
      return entries;
    }

    function sortStudents(entries, mode){
      const arr = [...entries];
      if(mode === "bib"){
        arr.sort((a,b)=>{
          const ax = (a.bib === null || a.bib === undefined) ? Number.POSITIVE_INFINITY : a.bib;
          const bx = (b.bib === null || b.bib === undefined) ? Number.POSITIVE_INFINITY : b.bib;
          if(ax !== bx) return ax - bx;
          return a.name.localeCompare(b.name);
        });
      }else if(mode === "name"){
        arr.sort((a,b)=>a.name.localeCompare(b.name));
      }
      return arr;
    }

    function displayStudentLabel(s){
      if(s.bib !== null && s.bib !== undefined) return `${s.bib} ${s.name}`;
      return s.name;
    }

    function buildParticipantMap(entries){
      return {
        version: 1,
        created_at: nowIso(),
        participants: entries.map(e => ({ name: e.name, bib: e.bib }))
      };
    }

    /**********************************************************************
     * GRID STATE
     **********************************************************************/
    let currentGroupName = "";
    let currentStudents = [];    // [{name,bib,label}]
    let currentMarks = {};       // key -> "Inc|Con|Refi"
    let pendingOps = [];         // queued cloud writes if offline

    function markKey(studentLabel, zoneId, task){
      return `${studentLabel}||${zoneId}||${task}`;
    }

    function getSelectedStatus(studentLabel, zoneId, task){
      return currentMarks[markKey(studentLabel, zoneId, task)] || "";
    }

    function setSelectedStatus(studentLabel, zoneId, task, status){
      const k = markKey(studentLabel, zoneId, task);
      if(!status) delete currentMarks[k];
      else currentMarks[k] = status;
    }

    function saveCurrentToLocal(note){
      if(!currentGroupName) return;

      const data = {
        groupName: currentGroupName,
        students: currentStudents.map(s => ({ name:s.name, bib:s.bib, label:s.label })),
        marks: currentMarks,
        pendingOps: pendingOps,
        updated_at: nowIso()
      };

      const all = loadAllLocal();
      all[currentGroupName] = data;
      saveAllLocal(all);

      localStorage.setItem(LS_LAST_GROUP, currentGroupName);
      refreshLocalGroupsUI();

      if(note) setMsg(note, false);
    }

    function loadGroupFromLocal(groupName){
      const all = loadAllLocal();
      const data = all[groupName];
      if(!data) return false;

      currentGroupName = data.groupName || groupName;
      currentStudents = (data.students || []).map(s => ({ ...s }));
      currentMarks = data.marks || {};
      pendingOps = data.pendingOps || [];
      document.getElementById("groupName").value = currentGroupName;
      document.getElementById("studentsInput").value = currentStudents.map(s => s.label).join(", ");
      renderGrid();
      setMsg("Loaded. Local marks kept where present.", false);
      return true;
    }

    /**********************************************************************
     * SUPABASE OPS
     **********************************************************************/
    async function ensureCourseRow(groupName, participantMap){
      const payload = {
        [COL_GROUP]: groupName,
        [COL_CLOSED]: false,
        [COL_PARTICIPANT_MAP]: participantMap,
        [COL_UPDATED]: nowIso()
      };

      const { error } = await supabase
        .from(COURSES_TABLE)
        .upsert([payload], { onConflict: COL_GROUP });

      if(error) throw error;
    }

    async function upsertEvaluationMark({ groupName, studentLabel, zoneId, task, status }){
      const payload = {
        [COL_GROUP]: groupName,
        [COL_STUDENT]: studentLabel,
        [COL_ZONE]: zoneId,
        [COL_TASK]: task,
        [COL_STATUS]: status,
        [COL_UPDATED]: nowIso()
      };

      // This triggers an UPSERT (POST with Prefer: resolution=merge-duplicates)
      const { error } = await supabase
        .from(EVAL_TABLE)
        .upsert([payload], { onConflict: `${COL_GROUP},${COL_STUDENT},${COL_ZONE},${COL_TASK}` });

      if(error) throw error;
    }

    async function deleteEvaluationMark({ groupName, studentLabel, zoneId, task }){
      // Only used when user clears a mark
      const { error } = await supabase
        .from(EVAL_TABLE)
        .delete()
        .eq(COL_GROUP, groupName)
        .eq(COL_STUDENT, studentLabel)
        .eq(COL_ZONE, zoneId)
        .eq(COL_TASK, task);

      if(error) throw error;
    }

    async function fetchCloudGroups(){
      const { data, error } = await supabase
        .from(COURSES_TABLE)
        .select(`${COL_GROUP}`)
        .order(COL_GROUP, { ascending:true });

      if(error) throw error;
      return (data || []).map(r => r[COL_GROUP]).filter(Boolean);
    }

    async function fetchCourseRow(groupName){
      const { data, error } = await supabase
        .from(COURSES_TABLE)
        .select(`${COL_GROUP}, ${COL_PARTICIPANT_MAP}`)
        .eq(COL_GROUP, groupName)
        .limit(1)
        .maybeSingle();

      if(error) throw error;
      return data || null;
    }

    async function fetchEvaluations(groupName){
      const { data, error } = await supabase
        .from(EVAL_TABLE)
        .select(`${COL_STUDENT}, ${COL_ZONE}, ${COL_TASK}, ${COL_STATUS}`)
        .eq(COL_GROUP, groupName);

      if(error) throw error;
      return data || [];
    }

    async function flushPendingOps(){
      if(!cloudReachable) return;
      if(pendingOps.length === 0) return;

      const ops = [...pendingOps];
      pendingOps = [];
      saveCurrentToLocal();

      for(const op of ops){
        try{
          if(op.type === "upsert"){
            await upsertEvaluationMark(op.payload);
          }else if(op.type === "delete"){
            await deleteEvaluationMark(op.payload);
          }
        }catch(e){
          // put back and stop
          pendingOps = [op, ...pendingOps];
          saveCurrentToLocal();
          throw e;
        }
      }
    }

    /**********************************************************************
     * RENDER GRID
     **********************************************************************/
    function renderGrid(){
      const tableWrap = document.getElementById("tableWrap");
      const table = document.getElementById("gridTable");

      if(!currentGroupName || currentStudents.length === 0){
        tableWrap.style.display = "none";
        table.innerHTML = "";
        return;
      }

      tableWrap.style.display = "block";

      let html = "<thead>";

      // Row 1: Task + student names (colspan=3 each)
      html += "<tr>";
      html += `<th class="taskHead">Task</th>`;
      for(const s of currentStudents){
        html += `<th class="studentHead" colspan="3">${escapeHtml(s.label)}</th>`;
      }
      html += "</tr>";

      // Row 2: blank under Task + Inc/Con/Refi labels
      html += "<tr>";
      html += `<th class="taskHead"></th>`;
      for(let i=0;i<currentStudents.length;i++){
        html += `<th class="subHead incCol">Inc</th>`;
        html += `<th class="subHead conCol">Con</th>`;
        html += `<th class="subHead refiCol">Refi</th>`;
      }
      html += "</tr>";
      html += "</thead>";

      html += "<tbody>";

      for(const z of ZONES){
        // Zone header row
        html += "<tr>";
        html += `<td class="zoneCell ${z.className}">`;
        html += `<div style="display:flex; align-items:center; gap:10px;">`;
        html += `<div style="display:flex; flex-direction:column;">`;
        html += `<div>${escapeHtml(z.title)}</div>`;
        html += `<small>${escapeHtml(z.subtitle)}</small>`;
        html += `</div>`;
        html += `<span class="infoBtn" data-zone="${z.id}" title="Info"></span>`;
        html += `</div>`;
        html += `</td>`;

        for(const s of currentStudents){
          html += `<td class="${z.className}" colspan="3" style="text-align:center; font-weight:900; font-size:22px;">${escapeHtml(s.label)}</td>`;
        }
        html += "</tr>";

        // Tasks
        for(const task of z.tasks){
          html += "<tr>";
          html += `<td class="taskCell">${escapeHtml(task)}</td>`;

          for(const s of currentStudents){
            const selected = getSelectedStatus(s.label, z.id, task);

            html += buildCell(s.label, z.id, task, "Inc", selected);
            html += buildCell(s.label, z.id, task, "Con", selected);
            html += buildCell(s.label, z.id, task, "Refi", selected);
          }

          html += "</tr>";
        }
      }

      html += "</tbody>";
      table.innerHTML = html;

      // Bind info buttons
      document.querySelectorAll(".infoBtn").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const zid = parseInt(btn.getAttribute("data-zone"),10);
          const zone = ZONES.find(x=>x.id===zid);
          if(!zone) return;
          openModal(zone.infoTitle, zone.infoText);
        });
      });

      // Bind mark buttons
      document.querySelectorAll(".mark-btn").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const student = btn.getAttribute("data-student");
          const zoneId = parseInt(btn.getAttribute("data-zone"), 10);
          const task = btn.getAttribute("data-task");
          const status = btn.getAttribute("data-status"); // Inc/Con/Refi

          await handleMarkClick(student, zoneId, task, status);
        });
      });
    }

    function buildCell(studentLabel, zoneId, task, status, selectedStatus){
      const cls = status === "Inc" ? "incCol" : status === "Con" ? "conCol" : "refiCol";
      const selectedClass =
        selectedStatus === status
          ? (status === "Inc" ? "selected inc" : status === "Con" ? "selected con" : "selected refi")
          : "";

      const markChar = (selectedStatus === status) ? "✓" : "";

      return `
        <td class="cell ${cls}">
          <div class="mark-btn ${selectedClass}"
               data-student="${escapeAttr(studentLabel)}"
               data-zone="${zoneId}"
               data-task="${escapeAttr(task)}"
               data-status="${status}">
            ${markChar}
          </div>
        </td>
      `;
    }

    async function handleMarkClick(studentLabel, zoneId, task, clickedStatus){
      if(!currentGroupName) return;

      const existing = getSelectedStatus(studentLabel, zoneId, task);

      // Toggle: clicking same status clears; clicking different status sets that one
      const next = (existing === clickedStatus) ? "" : clickedStatus;

      setSelectedStatus(studentLabel, zoneId, task, next);
      renderGrid();
      saveCurrentToLocal();

      // Attempt cloud write
      if(!cloudReachable){
        // Queue it
        if(next){
          pendingOps.push({
            type:"upsert",
            payload:{ groupName: currentGroupName, studentLabel, zoneId, task, status: next }
          });
        }else{
          pendingOps.push({
            type:"delete",
            payload:{ groupName: currentGroupName, studentLabel, zoneId, task }
          });
        }
        saveCurrentToLocal("Saved locally (offline).", false);
        return;
      }

      try{
        // Make sure course row exists (so other devices can pull participant map)
        const participantMap = buildParticipantMap(currentStudents.map(s=>({name:s.name, bib:s.bib})));
        await ensureCourseRow(currentGroupName, participantMap);

        if(next){
          await upsertEvaluationMark({ groupName: currentGroupName, studentLabel, zoneId, task, status: next });
        }else{
          await deleteEvaluationMark({ groupName: currentGroupName, studentLabel, zoneId, task });
        }

        await flushPendingOps();
        document.getElementById("syncText").textContent = "Synced";
        setMsg("Synced to cloud.", false);
      }catch(e){
        // Queue it if write fails
        if(next){
          pendingOps.push({
            type:"upsert",
            payload:{ groupName: currentGroupName, studentLabel, zoneId, task, status: next }
          });
        }else{
          pendingOps.push({
            type:"delete",
            payload:{ groupName: currentGroupName, studentLabel, zoneId, task }
          });
        }
        saveCurrentToLocal("Saved locally. Cloud write failed (will retry).", true);
      }
    }

    /**********************************************************************
     * CLOUD PULL (this is what makes laptop marks appear on phone)
     **********************************************************************/
    async function pullFromCloud(groupName){
      if(!groupName) return;
      if(!cloudReachable){
        setMsg("Cloud is not reachable right now.", true);
        return;
      }

      try{
        const course = await fetchCourseRow(groupName);
        if(!course){
          setMsg("Group not found in cloud.", true);
          return;
        }

        // Participant map drives stable ordering on all devices
        const pm = course[COL_PARTICIPANT_MAP];
        if(pm && pm.participants && Array.isArray(pm.participants)){
          currentStudents = pm.participants.map(p=>{
            const label = (p.bib !== null && p.bib !== undefined) ? `${p.bib} ${p.name}` : p.name;
            return { name:p.name, bib:p.bib, label };
          });
        }else{
          // fallback: keep whatever is local
          if(currentStudents.length === 0){
            setMsg("No participant map found in cloud for this group.", true);
          }
        }

        currentGroupName = groupName;
        document.getElementById("groupName").value = currentGroupName;
        document.getElementById("studentsInput").value = currentStudents.map(s=>s.label).join(", ");

        // Get marks from cloud
        const evals = await fetchEvaluations(groupName);

        // Replace currentMarks with cloud marks, but keep any pending local ops on top
        const cloudMarks = {};
        for(const r of evals){
          const s = r[COL_STUDENT];
          const z = r[COL_ZONE];
          const t = r[COL_TASK];
          const st = r[COL_STATUS];
          if(!s || !t || !z || !st) continue;
          cloudMarks[markKey(s, z, t)] = st;
        }

        currentMarks = cloudMarks;

        // Re-apply pending ops (local changes not yet synced)
        for(const op of pendingOps){
          const p = op.payload;
          if(op.type === "upsert"){
            currentMarks[markKey(p.studentLabel, p.zoneId, p.task)] = p.status;
          }
          if(op.type === "delete"){
            delete currentMarks[markKey(p.studentLabel, p.zoneId, p.task)];
          }
        }

        renderGrid();
        saveCurrentToLocal("Pulled from cloud and saved locally.", false);
      }catch(e){
        setMsg("Pull from cloud failed. Check RLS policies and column names.", true);
      }
    }

    /**********************************************************************
     * UI HELPERS
     **********************************************************************/
    function refreshLocalGroupsUI(){
      const sel = document.getElementById("savedGroups");
      const current = sel.value;

      const groups = listLocalGroups();
      sel.innerHTML = `<option value="">Select a saved group</option>` +
        groups.map(g => `<option value="${escapeAttr(g)}">${escapeHtml(g)}</option>`).join("");

      if(current && groups.includes(current)) sel.value = current;
    }

    async function refreshCloudGroupsUI(){
      if(!cloudReachable){
        setMsg("Cloud is not reachable right now.", true);
        return;
      }
      try{
        const groups = await fetchCloudGroups();
        const sel = document.getElementById("cloudGroups");
        sel.innerHTML = `<option value="">Select a cloud group</option>` +
          groups.map(g => `<option value="${escapeAttr(g)}">${escapeHtml(g)}</option>`).join("");
        setMsg("Cloud group list refreshed.", false);
      }catch(e){
        setMsg("Could not load cloud groups. Check RLS SELECT on courses.", true);
      }
    }

    function exportCSV(){
      if(!currentGroupName || currentStudents.length === 0){
        setMsg("No group loaded.", true);
        return;
      }

      const rows = [];
      rows.push(["group_name","student","zone","task","status"].join(","));

      for(const z of ZONES){
        for(const task of z.tasks){
          for(const s of currentStudents){
            const st = getSelectedStatus(s.label, z.id, task) || "";
            rows.push([
              csvCell(currentGroupName),
              csvCell(s.label),
              csvCell(z.id),
              csvCell(task),
              csvCell(st)
            ].join(","));
          }
        }
      }

      const blob = new Blob([rows.join("\n")], { type:"text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${currentGroupName}-assessment.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function csvCell(v){
      const s = String(v ?? "");
      if(/[,"\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
      return s;
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;");
    }
    function escapeAttr(s){
      return escapeHtml(s).replaceAll("'","&#39;");
    }

    /**********************************************************************
     * MODAL
     **********************************************************************/
    function openModal(title, content){
      document.getElementById("modalTitle").textContent = title || "Info";
      document.getElementById("modalContent").textContent = content || "";
      document.getElementById("modalBackdrop").style.display = "flex";
    }
    function closeModal(){
      document.getElementById("modalBackdrop").style.display = "none";
    }

    /**********************************************************************
     * APPLY LAYOUT
     **********************************************************************/
    async function applyLayout(){
      const groupName = (document.getElementById("groupName").value || "").trim();
      if(!groupName){
        setMsg("Please enter a group name.", true);
        return;
      }

      const rawStudents = document.getElementById("studentsInput").value || "";
      const sortMode = document.getElementById("sortMode").value;

      let entries = parseStudents(rawStudents);
      entries = sortStudents(entries, sortMode);

      if(entries.length === 0){
        setMsg("Please enter at least one student.", true);
        return;
      }

      currentGroupName = groupName;
      currentStudents = entries.map(e => ({ name:e.name, bib:e.bib, label:displayStudentLabel(e) }));
      currentMarks = currentMarks || {};
      pendingOps = pendingOps || [];

      renderGrid();
      saveCurrentToLocal("Layout applied and saved locally.", false);

      // Ensure course row exists in cloud so other devices see same participant order
      if(cloudReachable){
        try{
          const participantMap = buildParticipantMap(entries);
          await ensureCourseRow(currentGroupName, participantMap);
          setMsg("Layout applied. Participant map saved to cloud.", false);
        }catch(e){
          setMsg("Layout saved locally. Cloud write failed (check RLS / column name).", true);
        }
      }
    }

    /**********************************************************************
     * INIT
     **********************************************************************/
    function wireUI(){
      document.getElementById("applyBtn").addEventListener("click", applyLayout);

      document.getElementById("useGroupBtn").addEventListener("click", ()=>{
        const g = document.getElementById("savedGroups").value;
        if(!g) return;
        loadGroupFromLocal(g);
      });

      document.getElementById("loadLocalBtn").addEventListener("click", ()=>{
        const g = document.getElementById("savedGroups").value || localStorage.getItem(LS_LAST_GROUP) || "";
        if(!g){
          setMsg("Select a saved group first.", true);
          return;
        }
        const ok = loadGroupFromLocal(g);
        if(!ok) setMsg("Could not load that saved group.", true);
      });

      document.getElementById("exportBtn").addEventListener("click", exportCSV);

      document.getElementById("pullCloudBtn").addEventListener("click", async ()=>{
        const g = document.getElementById("cloudGroups").value;
        if(!g){
          setMsg("Select a cloud group first.", true);
          return;
        }
        await pullFromCloud(g);
      });

      document.getElementById("refreshCloudBtn").addEventListener("click", async ()=>{
        await checkCloudReachable();
        await refreshCloudGroupsUI();
      });

      document.getElementById("closeModalBtn").addEventListener("click", closeModal);
      document.getElementById("modalBackdrop").addEventListener("click", (e)=>{
        if(e.target.id === "modalBackdrop") closeModal();
      });

      window.addEventListener("online", async ()=>{
        await checkCloudReachable();
        if(cloudReachable){
          try{
            await flushPendingOps();
            document.getElementById("syncText").textContent = "Synced";
          }catch(e){}
        }
      });

      window.addEventListener("offline", ()=>{
        cloudReachable = false;
        updateOnlineUI();
      });
    }

    (async function init(){
      wireUI();
      refreshLocalGroupsUI();
      await checkCloudReachable();
      if(cloudReachable){
        await refreshCloudGroupsUI();
      }

      const last = localStorage.getItem(LS_LAST_GROUP);
      if(last){
        loadGroupFromLocal(last);
      }
    })();
  </script>
</body>
</html>