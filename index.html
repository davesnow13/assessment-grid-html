<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment Grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #f4f6f8;
      --border: #111;
      --header-bg: #e0e0e0;

      --inc-bg: #ffebee;
      --con-bg: #fffde7;
      --refi-bg: #e8f5e9;

      --zone1-bg: #e3f2fd;
      --zone2-bg: #e8f5e9;
      --zone3-bg: #fff3e0;

      --ok: #1b5e20;
      --bad: #b00020;
      --muted: #555;

      /* Key changes:
         1) Task column is clamped smaller on portrait (prevents it taking ~75%).
         2) Sticky z-index layering prevents participant headers from sliding over the task column.
      */
      --task-col-w: clamp(180px, 34vw, 260px);

      --cell-w: 56px;
      --cell-h: 46px;

      --header-row-h: 44px;
      --subheader-row-h: 38px;
    }

    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: var(--bg);
      color: #111;
    }

    h1{ margin: 0 0 4px 0; }

    .small{
      font-size: 0.95rem;
      color: var(--muted);
      margin: 0 0 12px 0;
      line-height: 1.25;
    }

    .controls{
      margin: 12px 0 12px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label{ font-size: 0.95rem; }

    input[type="text"], select{
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 1rem;
      background: #fff;
      min-width: 220px;
    }

    button{
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color: white;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
    }

    button.secondary{
      background: #5b636a;
      border-color: #4a5056;
    }

    button:disabled{
      opacity: 0.6;
      cursor: default;
    }

    #statusMsg{
      margin-top: 8px;
      font-size: 0.95rem;
      color: #111;
    }

    #statusMsg.error{ color: var(--bad); }
    #statusMsg.success{ color: var(--ok); }

    .banner{
      margin-top: 10px;
      border-radius: 10px;
      padding: 10px 12px;
      border: 1px solid #c9d1d9;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .banner-left{
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .dot{
      width: 14px; height: 14px;
      border-radius: 50%;
      background: #999;
      border: 1px solid #666;
    }
    .dot.online{ background: #2e7d32; border-color: #1b5e20; }
    .dot.offline{ background: #c62828; border-color: #8e0000; }
    .banner-right{
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 600;
    }

    /* Grid container */
    #gridWrap{
      margin-top: 12px;
      overflow: auto;
      border: 2px solid var(--border);
      border-radius: 10px;
      background: #fff;
      -webkit-overflow-scrolling: touch;
    }

    table{
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
      table-layout: fixed;
    }

    th, td{
      border: 2px solid var(--border);
      padding: 0;
      vertical-align: middle;
      background-clip: padding-box;
    }

    /* Task column sizing */
    .task-col{
      width: var(--task-col-w);
      min-width: 180px;
      max-width: 260px;
    }

    /* Participant column sizing */
    .mark-col{
      width: var(--cell-w);
      min-width: var(--cell-w);
      text-align: center;
    }

    /* Sticky headers */
    thead th{
      position: sticky;
      top: 0;
      background: var(--header-bg);
      z-index: 5; /* lower than task column */
    }

    /* Top-left corner cell should always be above everything */
    thead th.task-col{
      left: 0;
      z-index: 40;
      background: #fff;
      font-weight: 900;
      text-align: left;
      padding-left: 12px;
    }

    /* Sticky task column cells (body) */
    tbody td.task-col{
      position: sticky;
      left: 0;
      z-index: 30; /* above header row cells */
      background: #fff;
      padding: 10px 12px;
      font-size: 1.05rem;
      line-height: 1.2;

      /* Prevent long text forcing column wider */
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Optional: allow wrapping instead of ellipsis.
       If you prefer wrapping, comment out the 3 lines above and uncomment below.
    */
    /*
    tbody td.task-col{
      white-space: normal;
      overflow-wrap: anywhere;
    }
    */

    /* Participant header cells */
    .student-header{
      height: var(--header-row-h);
      font-weight: 900;
      font-size: 1.15rem;
      text-align: center;
      background: var(--header-bg);
      z-index: 5;
    }

    /* Subheader row for Inc/Con/Refi */
    .subheader{
      position: sticky;
      top: var(--header-row-h);
      z-index: 4; /* still below task column */
      font-weight: 900;
      font-size: 1.05rem;
      height: var(--subheader-row-h);
      text-align: center;
      background: #fff;
    }

    .sub-inc{ background: var(--inc-bg); }
    .sub-con{ background: var(--con-bg); }
    .sub-refi{ background: var(--refi-bg); }

    /* Zone title row */
    .zone-row td.task-col{
      font-weight: 900;
      font-size: 1.25rem;
      padding: 10px 12px;
    }
    .zone-meta{
      display: block;
      font-weight: 700;
      font-size: 0.95rem;
      color: #222;
      margin-top: 2px;
      opacity: 0.85;
    }
    .zone1 td, .zone1 td.task-col{ background: var(--zone1-bg) !important; }
    .zone2 td, .zone2 td.task-col{ background: var(--zone2-bg) !important; }
    .zone3 td, .zone3 td.task-col{ background: var(--zone3-bg) !important; }

    /* Mark cells */
    .mark-cell{
      height: var(--cell-h);
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
      cursor: pointer;
    }
    .mark-box{
      width: 34px;
      height: 34px;
      border-radius: 6px;
      border: 2px solid #999;
      background: #e9ecef;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 900;
      color: #fff;
    }

    .is-inc .mark-box{ background: #c62828; border-color: #8e0000; }
    .is-con .mark-box{ background: #f9a825; border-color: #c17900; color: #111; }
    .is-refi .mark-box{ background: #2e7d32; border-color: #1b5e20; }

    .col-inc{ background: var(--inc-bg); }
    .col-con{ background: var(--con-bg); }
    .col-refi{ background: var(--refi-bg); }

    /* Info button */
    .info-btn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #222;
      background: #fff;
      color: #111;
      font-weight: 900;
      margin-left: 10px;
      cursor: pointer;
      user-select: none;
    }

    /* Modal */
    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .modal{
      width: min(720px, 96vw);
      max-height: 86vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      border: 2px solid #111;
      padding: 16px 16px 14px 16px;
    }
    .modal h2{
      margin: 0 0 8px 0;
      font-size: 1.25rem;
    }
    .modal .section-title{
      font-weight: 900;
      margin-top: 12px;
      margin-bottom: 6px;
    }
    .modal ul{
      margin: 6px 0 0 22px;
    }
    .modal .close-row{
      display: flex;
      justify-content: flex-end;
      margin-top: 12px;
    }
    .modal .close-btn{
      background: #5b636a;
      border-color: #4a5056;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 900;
      color: #fff;
      cursor: pointer;
    }

    /* Portrait tuning */
    @media (max-width: 520px){
      :root{
        --task-col-w: clamp(170px, 32vw, 240px);
        --cell-w: 54px;
      }
      input[type="text"], select{ min-width: 170px; }
      .small{ font-size: 0.9rem; }
    }

    /* Landscape tuning */
    @media (orientation: landscape){
      :root{
        --task-col-w: clamp(220px, 24vw, 340px);
      }
    }

    /* Print */
    @media print{
      body{ background: #fff; padding: 0; }
      .controls, #statusMsg, .banner{ display: none !important; }
      #gridWrap{ border: none; }
      *{
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to toggle Inc (red), Con (yellow), Refi (green), then blank.
    Data is saved locally first and synced to Supabase automatically when possible.
    You can also export to CSV.
  </div>

  <div class="controls">
    <label>
      Group name:
      <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />
    </label>

    <label>
      Students:
      <input id="studentsInput" type="text" placeholder="Reuben, Albert, Benedict" />
    </label>

    <button id="applyBtn">Apply layout</button>
  </div>

  <div class="controls">
    <button id="loadLocalBtn">Load saved marks</button>
    <button id="exportCsvBtn" class="secondary">Export CSV (this group)</button>

    <label style="margin-left: 6px;">
      Saved groups:
      <select id="savedGroupsSelect">
        <option value="">Select a saved group</option>
      </select>
    </label>
    <button id="useGroupBtn" class="secondary">Use group</button>
  </div>

  <div id="statusMsg"></div>

  <div class="banner" id="netBanner">
    <div class="banner-left">
      <span class="dot" id="netDot"></span>
      <span id="netText">Checking connection...</span>
    </div>
    <div class="banner-right" id="syncText">-</div>
  </div>

  <div id="gridWrap"></div>

  <!-- Info modal -->
  <div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="modalTitle">Information</h2>

      <div class="section-title" id="modalSectionA">Possible constraints</div>
      <ul id="modalListA"></ul>

      <div class="section-title" id="modalSectionB">Evaluation focus</div>
      <ul id="modalListB"></ul>

      <div class="close-row">
        <button class="close-btn" id="closeModalBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    /***********************
     * CONFIG
     ***********************/
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const LS_KEY = "snowboard_assessment_groups_v3";
    const STATUS_ORDER = ["", "Inc", "Con", "Refi"];

    const ZONES = [
      {
        id: 1,
        title: "Zone 1",
        subtitle: "FLATS AND MAGIC CARPET AREA",
        cssClass: "zone1",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        info: {
          aTitle: "Possible constraints",
          a: [
            "Glide with reduced space or toward a target marker.",
            "Perform skating tasks with a variable snow surface (slightly packed or soft).",
            "Skating around obstacles (example: cones, stubbies).",
            "Use minor slope gradient to encourage longer glide or speed awareness."
          ],
          bTitle: "Evaluation focus",
          b: [
            "Balance and coordination while gliding",
            "Smooth push and glide transitions",
            "Controlled direction and stopping",
            "Awareness of surrounding space and other riders"
          ]
        }
      },
      {
        id: 2,
        title: "Zone 2",
        subtitle: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        cssClass: "zone2",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        info: {
          aTitle: "Possible variations",
          a: [
            "Perform a controlled stop during a sideslip or traverse.",
            "Link multiple turns with slight changes in snow texture or slope pitch.",
            "Ride both toe and heel sides in the same run.",
            "Follow a marked path or cone line to encourage directional awareness."
          ],
          bTitle: "Evaluation focus",
          b: [
            "Smooth loading and unloading of the magic carpet",
            "Balanced posture while standing on both edges",
            "Controlled side slips without abrupt stops",
            "Stable traverses across the slope",
            "Linked turns showing direction and speed control"
          ]
        }
      },
      {
        id: 3,
        title: "Zone 3",
        subtitle: "FLAGGED GREEN RUN",
        cssClass: "zone3",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        info: {
          aTitle: "Evaluation focus",
          a: [
            "Continuous linked turns along the flagged path",
            "Speed managed through turn shape, not braking",
            "Controlled edge release and engagement",
            "Flow maintained through variable turn timing",
            "Adaptability to terrain, snow, and surrounding traffic"
          ],
          bTitle: "",
          b: []
        }
      }
    ];

    /***********************
     * UI
     ***********************/
    const groupNameEl = document.getElementById("groupName");
    const studentsInputEl = document.getElementById("studentsInput");
    const applyBtn = document.getElementById("applyBtn");
    const loadLocalBtn = document.getElementById("loadLocalBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const savedGroupsSelect = document.getElementById("savedGroupsSelect");
    const useGroupBtn = document.getElementById("useGroupBtn");
    const statusMsg = document.getElementById("statusMsg");
    const gridWrap = document.getElementById("gridWrap");

    const netDot = document.getElementById("netDot");
    const netText = document.getElementById("netText");
    const syncText = document.getElementById("syncText");

    const modalBackdrop = document.getElementById("modalBackdrop");
    const closeModalBtn = document.getElementById("closeModalBtn");
    const modalTitle = document.getElementById("modalTitle");
    const modalSectionA = document.getElementById("modalSectionA");
    const modalSectionB = document.getElementById("modalSectionB");
    const modalListA = document.getElementById("modalListA");
    const modalListB = document.getElementById("modalListB");

    /***********************
     * STATE
     ***********************/
    let currentGroup = "";
    let students = [];
    let marks = {};

    let onlineState = false;
    let syncingNow = false;

    let lastScrollLeft = 0;
    let lastScrollTop = 0;

    /***********************
     * UTIL
     ***********************/
    function setMessage(text, isError=false){
      statusMsg.textContent = text;
      statusMsg.className = isError ? "error" : "success";
    }
    function clearMessage(){
      statusMsg.textContent = "";
      statusMsg.className = "";
    }
    function normGroupName(s){ return (s || "").trim(); }
    function parseStudents(s){
      return (s || "")
        .split(",")
        .map(x => x.trim())
        .filter(Boolean);
    }
    function zoneTaskKey(zoneId, task){ return zoneId + "::" + task; }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function captureScroll(){
      lastScrollLeft = gridWrap.scrollLeft;
      lastScrollTop = gridWrap.scrollTop;
    }
    function restoreScroll(){
      gridWrap.scrollLeft = lastScrollLeft;
      gridWrap.scrollTop = lastScrollTop;
    }

    function loadAllLocal(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === "object") ? obj : {};
      }catch(e){
        console.error(e);
        return {};
      }
    }
    function saveAllLocal(obj){
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }
    function upsertLocalGroup(groupName, groupObj){
      const all = loadAllLocal();
      all[groupName] = groupObj;
      saveAllLocal(all);
      refreshSavedGroupsDropdown();
    }
    function getLocalGroup(groupName){
      const all = loadAllLocal();
      return all[groupName] || null;
    }
    function refreshSavedGroupsDropdown(){
      const all = loadAllLocal();
      const names = Object.keys(all).sort((a,b)=>a.localeCompare(b));

      while(savedGroupsSelect.options.length > 1){
        savedGroupsSelect.remove(1);
      }
      names.forEach(n=>{
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        savedGroupsSelect.appendChild(opt);
      });
    }

    function setOnlineBanner(isOnline, extraText){
      onlineState = isOnline;
      if(isOnline){
        netDot.className = "dot online";
        netText.textContent = "Online: cloud is reachable.";
        syncText.textContent = syncingNow ? "Syncing..." : (extraText || "Synced");
      }else{
        netDot.className = "dot offline";
        netText.textContent = "Offline: showing marks stored on this device.";
        syncText.textContent = syncingNow ? "Syncing..." : (extraText || "Local only");
      }
    }

    async function checkCloudReachable(){
      try{
        const { error } = await db.from("courses").select("group_name").limit(1);
        if(error){
          setOnlineBanner(false, "Local only");
          return false;
        }
        setOnlineBanner(true, syncingNow ? "Syncing..." : "Synced");
        return true;
      }catch(e){
        setOnlineBanner(false, "Local only");
        return false;
      }
    }

    /***********************
     * MODAL
     ***********************/
    function openInfoModal(zone){
      modalTitle.textContent = zone.title + ": " + zone.subtitle;

      modalSectionA.textContent = zone.info.aTitle || "";
      modalSectionB.textContent = zone.info.bTitle || "";

      modalListA.innerHTML = "";
      modalListB.innerHTML = "";

      (zone.info.a || []).forEach(x=>{
        const li = document.createElement("li");
        li.textContent = x;
        modalListA.appendChild(li);
      });

      (zone.info.b || []).forEach(x=>{
        const li = document.createElement("li");
        li.textContent = x;
        modalListB.appendChild(li);
      });

      modalSectionA.style.display = zone.info.aTitle ? "block" : "none";
      modalListA.style.display = (zone.info.a && zone.info.a.length) ? "block" : "none";
      modalSectionB.style.display = zone.info.bTitle ? "block" : "none";
      modalListB.style.display = (zone.info.b && zone.info.b.length) ? "block" : "none";

      modalBackdrop.style.display = "flex";
    }
    function closeInfoModal(){
      modalBackdrop.style.display = "none";
    }
    closeModalBtn.addEventListener("click", closeInfoModal);
    modalBackdrop.addEventListener("click", (e)=>{
      if(e.target === modalBackdrop) closeInfoModal();
    });

    /***********************
     * MARKS SHAPE + GRID
     ***********************/
    function buildEmptyMarks(){
      marks = {};
      ZONES.forEach(z=>{
        z.tasks.forEach(t=>{
          const key = zoneTaskKey(z.id, t);
          marks[key] = {};
          students.forEach(s=>{
            marks[key][s] = "";
          });
        });
      });
    }

    function ensureMarksShape(){
      ZONES.forEach(z=>{
        z.tasks.forEach(t=>{
          const key = zoneTaskKey(z.id, t);
          if(!marks[key]) marks[key] = {};
          students.forEach(s=>{
            if(!(s in marks[key])) marks[key][s] = "";
          });
          Object.keys(marks[key]).forEach(s=>{
            if(!students.includes(s)) delete marks[key][s];
          });
        });
      });
    }

    function renderStatusCell(zoneId, task, student, cellStatus, currentValue){
      const isSelected = (currentValue === cellStatus);
      const cls =
        isSelected
          ? (cellStatus === "Inc" ? "is-inc" : cellStatus === "Con" ? "is-con" : "is-refi")
          : "";

      const bgCls =
        cellStatus === "Inc" ? "col-inc" : cellStatus === "Con" ? "col-con" : "col-refi";

      const check = isSelected ? "âœ“" : "";

      const payload = encodeURIComponent(JSON.stringify({
        z: zoneId,
        t: task,
        s: student,
        set: cellStatus
      }));

      return `
        <td class="mark-col ${bgCls}">
          <div class="mark-cell ${cls}" data-mark="${payload}">
            <div class="mark-box">${check}</div>
          </div>
        </td>
      `;
    }

    function renderGrid(){
      if(!currentGroup || students.length === 0){
        gridWrap.innerHTML = "";
        return;
      }

      ensureMarksShape();
      captureScroll();

      let html = "<table>";

      html += "<thead>";
      html += "<tr>";
      html += `<th class="task-col">Task</th>`;
      students.forEach(st=>{
        html += `<th class="student-header" colspan="3">${escapeHtml(st)}</th>`;
      });
      html += "</tr>";

      html += "<tr>";
      html += `<th class="task-col"></th>`;
      students.forEach(()=>{
        html += `<th class="subheader sub-inc mark-col">Inc</th>`;
        html += `<th class="subheader sub-con mark-col">Con</th>`;
        html += `<th class="subheader sub-refi mark-col">Refi</th>`;
      });
      html += "</tr>";
      html += "</thead>";

      html += "<tbody>";

      ZONES.forEach(zone=>{
        html += `<tr class="zone-row ${zone.cssClass}">`;
        html += `<td class="task-col">
          ${zone.title}
          <span class="zone-meta">${escapeHtml(zone.subtitle)}</span>
          <span class="info-btn" data-zone="${zone.id}" title="Info">i</span>
        </td>`;

        students.forEach(st=>{
          html += `<td class="mark-col" colspan="3" style="font-weight:900;font-size:1.4rem;text-align:center;">
            ${escapeHtml(st)}
          </td>`;
        });
        html += "</tr>";

        zone.tasks.forEach(task=>{
          const key = zoneTaskKey(zone.id, task);

          html += "<tr>";
          html += `<td class="task-col" title="${escapeHtml(task)}">${escapeHtml(task)}</td>`;

          students.forEach(st=>{
            const v = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            html += renderStatusCell(zone.id, task, st, "Inc", v);
            html += renderStatusCell(zone.id, task, st, "Con", v);
            html += renderStatusCell(zone.id, task, st, "Refi", v);
          });

          html += "</tr>";
        });
      });

      html += "</tbody>";
      html += "</table>";

      gridWrap.innerHTML = html;

      gridWrap.querySelectorAll("[data-mark]").forEach(el=>{
        el.addEventListener("click", onMarkClick);
      });

      gridWrap.querySelectorAll(".info-btn").forEach(btn=>{
        btn.addEventListener("click", (e)=>{
          const zid = Number(e.currentTarget.getAttribute("data-zone"));
          const zone = ZONES.find(z=>z.id === zid);
          if(zone) openInfoModal(zone);
        });
      });

      restoreScroll();
    }

    function onMarkClick(e){
      captureScroll();

      const payload = e.currentTarget.getAttribute("data-mark");
      if(!payload) return;

      const obj = JSON.parse(decodeURIComponent(payload));
      const key = zoneTaskKey(obj.z, obj.t);

      if(!marks[key]) marks[key] = {};
      const cur = marks[key][obj.s] || "";

      let next = obj.set;
      if(cur === obj.set) next = "";

      marks[key][obj.s] = next;

      saveCurrentGroupLocal("Local marks saved.");
      scheduleSync();

      renderGrid();
      restoreScroll();
    }

    /***********************
     * LOCAL SAVE/LOAD
     ***********************/
    function getCurrentLocalObject(){
      return {
        group_name: currentGroup,
        students: students.slice(),
        marks: marks,
        updated_at: Date.now()
      };
    }

    function saveCurrentGroupLocal(message){
      if(!currentGroup) return;
      upsertLocalGroup(currentGroup, getCurrentLocalObject());
      if(message) setMessage(message, false);
    }

    function loadGroupFromLocal(groupName){
      const obj = getLocalGroup(groupName);
      if(!obj) return false;

      currentGroup = obj.group_name || groupName;
      students = Array.isArray(obj.students) ? obj.students.slice() : [];
      marks = obj.marks && typeof obj.marks === "object" ? obj.marks : {};

      groupNameEl.value = currentGroup;
      studentsInputEl.value = students.join(", ");

      ensureMarksShape();
      renderGrid();
      setMessage("Loaded. Local marks kept where present.", false);
      return true;
    }

    /***********************
     * SUPABASE SYNC
     ***********************/
    function buildRowsForDb(){
      const rows = [];
      ZONES.forEach(z=>{
        z.tasks.forEach(task=>{
          const key = zoneTaskKey(z.id, task);
          students.forEach(st=>{
            const status = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            if(!status) return;
            rows.push({
              group_name: currentGroup,
              student: st,
              zone: z.id,
              task: task,
              status: status
            });
          });
        });
      });
      return rows;
    }

    async function syncNow(){
      if(!currentGroup || students.length === 0) return;
      if(syncingNow) return;

      syncingNow = true;
      setOnlineBanner(onlineState, "Syncing...");

      const canReach = await checkCloudReachable();
      if(!canReach){
        syncingNow = false;
        setOnlineBanner(false, "Local only");
        return;
      }

      try{
        await db.from("courses").upsert(
          [{ group_name: currentGroup, is_closed: false }],
          { onConflict: "group_name" }
        );

        const del = await db.from("evaluations").delete().eq("group_name", currentGroup);
        if(del.error){
          console.warn("Delete error:", del.error);
        }

        const rows = buildRowsForDb();
        if(rows.length > 0){
          const ins = await db.from("evaluations").insert(rows);
          if(ins.error){
            console.error(ins.error);
            setMessage("Sync failed: could not write to cloud. Local marks are safe.", true);
            syncingNow = false;
            setOnlineBanner(true, "Sync error");
            return;
          }
        }

        setMessage("Synced to cloud.", false);
        syncingNow = false;
        setOnlineBanner(true, "Synced");
      }catch(e){
        console.error(e);
        syncingNow = false;
        setMessage("Sync failed. Local marks are safe.", true);
        setOnlineBanner(false, "Local only");
      }
    }

    let syncTimer = null;
    function scheduleSync(){
      if(syncTimer) clearTimeout(syncTimer);
      syncTimer = setTimeout(async ()=>{ await syncNow(); }, 900);
    }

    /***********************
     * CSV
     ***********************/
    function exportCsv(){
      if(!currentGroup || students.length === 0){
        setMessage("Enter a group and students first.", true);
        return;
      }

      const headers = ["group_name","student","zone","task","status"];
      const lines = [headers.join(",")];

      ZONES.forEach(z=>{
        z.tasks.forEach(task=>{
          const key = zoneTaskKey(z.id, task);
          students.forEach(st=>{
            const status = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            if(!status) return;

            const row = {
              group_name: currentGroup,
              student: st,
              zone: z.id,
              task: task,
              status: status
            };

            const values = headers.map(h=>{
              let v = row[h];
              if(v == null) v = "";
              v = String(v).replace(/"/g,'""');
              if(v.search(/[",\n]/) !== -1) v = `"${v}"`;
              return v;
            });

            lines.push(values.join(","));
          });
        });
      });

      const content = lines.join("\n");
      const blob = new Blob([content], {type:"text/csv;charset=utf-8;"});
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `snowboard_assessment_${currentGroup.replace(/\s+/g,"_")}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setMessage("CSV exported for this group.", false);
    }

    /***********************
     * EVENTS
     ***********************/
    applyBtn.addEventListener("click", async ()=>{
      clearMessage();

      const g = normGroupName(groupNameEl.value);
      if(!g){
        setMessage("Enter a group name.", true);
        return;
      }

      const st = parseStudents(studentsInputEl.value);
      if(st.length === 0){
        setMessage("Enter at least one student name.", true);
        return;
      }

      currentGroup = g;
      students = st;

      const existing = getLocalGroup(currentGroup);
      if(existing){
        marks = existing.marks || {};
        ensureMarksShape();
        saveCurrentGroupLocal("Loaded existing local group and kept marks.");
      }else{
        buildEmptyMarks();
        saveCurrentGroupLocal("Group created locally.");
      }

      renderGrid();
      await checkCloudReachable();
      scheduleSync();
      setMessage("Layout applied.", false);
    });

    loadLocalBtn.addEventListener("click", ()=>{
      clearMessage();
      const g = normGroupName(groupNameEl.value);
      if(!g){
        setMessage("Enter a group name, or select a saved group.", true);
        return;
      }
      const ok = loadGroupFromLocal(g);
      if(!ok) setMessage("No local marks found for that group name.", true);
    });

    useGroupBtn.addEventListener("click", ()=>{
      clearMessage();
      const selected = savedGroupsSelect.value;
      if(!selected){
        setMessage("Select a saved group first.", true);
        return;
      }
      const ok = loadGroupFromLocal(selected);
      if(!ok){
        setMessage("Could not load that saved group.", true);
      }else{
        scheduleSync();
      }
    });

    exportCsvBtn.addEventListener("click", exportCsv);

    async function heartbeat(){
      if(syncingNow) return;
      await checkCloudReachable();
    }

    (async function init(){
      refreshSavedGroupsDropdown();
      setOnlineBanner(false, "Checking...");
      await checkCloudReachable();
      setInterval(heartbeat, 12000);
    })();
  </script>
</body>
</html>