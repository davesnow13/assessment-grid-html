<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment Grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: #f4f6f8;
    }

    h1 { margin-bottom: 4px; }

    .small { font-size: 0.85rem; color: #555; }

    .controls {
      margin: 12px 0 14px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label { font-size: 0.9rem; }

    input[type="text"], select {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 0.95rem;
      background: #fff;
    }

    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color: white;
      cursor: pointer;
      font-size: 0.95rem;
    }

    button.secondary {
      background: #5b636a;
      border-color: #4a5056;
    }

    button:disabled { opacity: 0.6; cursor: default; }

    /* Connection status banner */
    #connectionStatus {
      margin: 10px 0 10px 0;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #c9d1d9;
      background: #ffffff;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #connectionStatus .left {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    #connectionStatus .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex: 0 0 auto;
      border: 1px solid rgba(0,0,0,0.2);
    }

    #connectionStatus .text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #connectionStatus .right {
      flex: 0 0 auto;
      font-size: 0.85rem;
      color: #555;
      white-space: nowrap;
    }

    #connectionStatus.online .dot { background: #2e7d32; }
    #connectionStatus.online { border-color: #b7dfc2; background: #f1fbf3; }

    #connectionStatus.offline .dot { background: #616161; }
    #connectionStatus.offline { border-color: #d0d0d0; background: #f6f6f6; }

    #tableContainer {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      background: white;
      min-width: 700px;
    }

    th, td {
      border: 2px solid #000;
      padding: 6px 4px;
      text-align: center;
      font-size: 0.85rem;
    }

    th.task-col,
    td.task-col {
      text-align: left;
      min-width: 70px;
      max-width: 85px;
      background: #f9fbfd;
      position: sticky;
      left: 0;
      z-index: 3;
      white-space: normal;
      word-break: break-word;
      padding-left: 4px;
      padding-right: 4px;
      line-height: 1.1;
    }

    th.zone-header { text-align: left; font-size: 0.95rem; }
    th.student-group-header { background: #d9dde0; }
    th.status-header { font-size: 0.75rem; }

    .zone-row-1 th { background: #e3f2fd; }
    .zone-row-2 th { background: #e8f5e9; }
    .zone-row-3 th { background: #fff3e0; }

    .status-cell { background: #f5f5f5; }

    .status-inner {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #e9ecef;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .status-inner.selected::after {
      content: "✓";
      color: white;
      font-size: 0.8rem;
    }

    .status-header[data-status="Inc"],
    .status-cell[data-status="Inc"] { background: #ffebee; }
    .status-inner[data-status="Inc"].selected { background: #c62828; border-color: #8e0000; }

    .status-header[data-status="Con"],
    .status-cell[data-status="Con"] { background: #fffde7; }
    .status-inner[data-status="Con"].selected { background: #f9a825; border-color: #c17900; }

    .status-header[data-status="Refi"],
    .status-cell[data-status="Refi"] { background: #e8f5e9; }
    .status-inner[data-status="Refi"].selected { background: #2e7d32; border-color: #1b5e20; }

    .message { margin-top: 8px; font-size: 0.8rem; color: #444; }
    .error { color: #b00020; }
    .success { color: #1b5e20; }

    @media (max-width: 600px) {
      th.task-col, td.task-col {
        min-width: 95px;
        max-width: 115px;
        font-size: 0.72rem;
        line-height: 1.15;
      }
      table { font-size: 0.75rem; }
      th, td { padding: 4px 2px; }
      .status-inner { width: 26px; height: 26px; }
    }

    @media (pointer: coarse) {
      .status-inner { width: 30px; height: 30px; }
      th, td { padding-top: 6px; padding-bottom: 6px; }
    }
  </style>
</head>
<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and
    synced to Supabase automatically when possible. You can also export to CSV.
  </div>

  <div class="controls">
    <label>
      Group name:
      <input id="groupNameInput" type="text" placeholder="e.g. Lake Louise Group A" />
    </label>

    <label>
      Students:
      <input id="studentsInput" type="text" value="Reuben, Albert, Benedict" />
    </label>

    <button id="applyLayoutBtn">Apply layout</button>
    <button id="loadBtn">Load saved marks</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
  </div>

  <div class="controls">
    <label>
      Saved groups:
      <select id="groupSelect">
        <option value="">Select a saved group</option>
      </select>
    </label>
    <button id="useGroupBtn" class="secondary">Use group</button>
  </div>

  <div id="connectionStatus" class="offline" aria-live="polite">
    <div class="left">
      <span class="dot" aria-hidden="true"></span>
      <div class="text" id="connectionText">Checking cloud connection…</div>
    </div>
    <div class="right" id="connectionRight">—</div>
  </div>

  <div id="statusMsg" class="message"></div>
  <div id="tableContainer"></div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const STATUSES = ["Inc", "Con", "Refi"];

    const TASKS = [
      { zone: 1, label: "Load and unload a chairlift and Riding the magic carpet" },
      { zone: 1, label: "Skating in a straight line" },
      { zone: 1, label: "Skate around cones" },
      { zone: 1, label: "Skate across a slope on both edges" },
      { zone: 1, label: "Switch skating in straight line" },
      { zone: 1, label: "J-turns" },

      { zone: 2, label: "Stand up on both edges" },
      { zone: 2, label: "Sideslip both edges" },
      { zone: 2, label: "Traversing on both edges" },
      { zone: 2, label: "Turning edge to edge down fall line (Linked turns)" },

      { zone: 3, label: "Linked Turns (Continuous)" },
      { zone: 3, label: "Speed Control Through Turn Shape" },
      { zone: 3, label: "Edge Release and Engagement" },
      { zone: 3, label: "Flow and Continuity" },
      { zone: 3, label: "Adaptability" }
    ];

    const groupNameInput = document.getElementById("groupNameInput");
    const studentsInput = document.getElementById("studentsInput");
    const tableContainer = document.getElementById("tableContainer");
    const statusMsg = document.getElementById("statusMsg");
    const exportBtn = document.getElementById("exportBtn");
    const groupSelect = document.getElementById("groupSelect");
    const useGroupBtn = document.getElementById("useGroupBtn");

    const connectionStatusEl = document.getElementById("connectionStatus");
    const connectionTextEl = document.getElementById("connectionText");
    const connectionRightEl = document.getElementById("connectionRight");

    let currentStudents = [];

    const LOCAL_STATE_PREFIX = "assessmentGrid_state_";
    const LOCAL_QUEUE_KEY = "assessmentGrid_queue_v1";
    const LOCAL_GROUPS_KEY = "assessmentGrid_groups";
    const LOCAL_ROSTER_PREFIX = "assessmentGrid_roster_";

    let cloudReachable = false;

    function setMessage(text, isError = false) {
      statusMsg.textContent = text;
      statusMsg.className = "message " + (isError ? "error" : "success");
    }

    function clearMessage() {
      statusMsg.textContent = "";
      statusMsg.className = "message";
    }

    function parseStudents() {
      return studentsInput.value
        .split(",")
        .map(s => s.trim())
        .filter(s => s.length > 0);
    }

    // Roster persistence
    function saveRoster(groupName, students) {
      try { localStorage.setItem(LOCAL_ROSTER_PREFIX + groupName, JSON.stringify(students)); } catch {}
    }
    function loadRoster(groupName) {
      try {
        const raw = localStorage.getItem(LOCAL_ROSTER_PREFIX + groupName);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed : [];
      } catch { return []; }
    }

    // Group list
    function loadGroupList() {
      try {
        const raw = localStorage.getItem(LOCAL_GROUPS_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }
    function saveGroupList(list) {
      try { localStorage.setItem(LOCAL_GROUPS_KEY, JSON.stringify(list)); } catch {}
    }
    function registerGroupName(groupName) {
      if (!groupName) return;
      const list = loadGroupList();
      if (!list.includes(groupName)) {
        list.push(groupName);
        saveGroupList(list);
      }
    }

    // Local state
    function localKey(student, zone, task) {
      return `${student}|${zone}|${task}`;
    }
    function loadGroupState(groupName) {
      if (!groupName) return {};
      try {
        const raw = localStorage.getItem(LOCAL_STATE_PREFIX + groupName);
        return raw ? JSON.parse(raw) : {};
      } catch { return {}; }
    }
    function saveGroupState(groupName, state) {
      if (!groupName) return;
      try { localStorage.setItem(LOCAL_STATE_PREFIX + groupName, JSON.stringify(state)); } catch {}
    }
    function updateLocalState(groupName, student, zone, task, status) {
      const key = localKey(student, zone, task);
      const state = loadGroupState(groupName);
      state[key] = status;
      saveGroupState(groupName, state);
      registerGroupName(groupName);

      const roster = loadRoster(groupName);
      if (roster.length === 0) {
        const parsed = parseStudents();
        if (parsed.length > 0) saveRoster(groupName, parsed);
      }
    }

    function applyLocalStateToUI(groupName) {
      const state = loadGroupState(groupName);
      Object.entries(state).forEach(([k, status]) => {
        const [student, zone, task] = k.split("|");
        const selectorAll =
          `.status-inner[data-student="${encodeURIComponent(student)}"]` +
          `[data-zone="${zone}"][data-task="${encodeURIComponent(task)}"]`;
        const selectorOne = selectorAll + `[data-status="${status}"]`;
        const cellToSelect = document.querySelector(selectorOne);
        if (!cellToSelect) return;
        document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
        cellToSelect.classList.add("selected");
      });
    }

    // Offline queue
    function loadQueue() {
      try {
        const raw = localStorage.getItem(LOCAL_QUEUE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }
    function saveQueue(queue) {
      try { localStorage.setItem(LOCAL_QUEUE_KEY, JSON.stringify(queue)); } catch {}
    }
    function enqueueOp(op) {
      let queue = loadQueue();
      queue = queue.filter(q => !(q.group_name === op.group_name && q.student === op.student && q.zone === op.zone && q.task === op.task));
      queue.push(op);
      saveQueue(queue);
    }
    function getQueueCount() {
      const q = loadQueue();
      return Array.isArray(q) ? q.length : 0;
    }

    // iOS-proof "cloud reachable" check (short timeout)
    async function checkCloudReachable(timeoutMs = 2000) {
      try {
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), timeoutMs);

        // A tiny request to Supabase REST endpoint. If it returns 401/403 that is still "reachable".
        const url = SUPABASE_URL + "/rest/v1/";
        const res = await fetch(url, {
          method: "GET",
          headers: { apikey: SUPABASE_ANON_KEY },
          signal: controller.signal
        });

        clearTimeout(t);
        return !!res; // if fetch succeeded, backend is reachable
      } catch {
        return false;
      }
    }

    function updateConnectionIndicator() {
      const queueCount = getQueueCount();

      if (cloudReachable) {
        connectionStatusEl.classList.add("online");
        connectionStatusEl.classList.remove("offline");
        connectionTextEl.textContent = "Online: cloud is reachable.";
        connectionRightEl.textContent = queueCount > 0 ? ("Pending sync: " + queueCount) : "Synced";
      } else {
        connectionStatusEl.classList.add("offline");
        connectionStatusEl.classList.remove("online");
        connectionTextEl.textContent = "Offline: cloud not reachable (saving locally).";
        connectionRightEl.textContent = queueCount > 0 ? ("Queued: " + queueCount) : "Local only";
      }
    }

    async function refreshConnectivity() {
      // hint only, do not trust it
      connectionTextEl.textContent = "Checking cloud connection…";
      connectionRightEl.textContent = "—";

      cloudReachable = await checkCloudReachable(2000);
      updateConnectionIndicator();
    }

    async function trySaveToSupabase(op, isRetry = false) {
      // never block local save
      if (!cloudReachable) {
        enqueueOp(op);
        if (!isRetry) setMessage("Saved locally. Cloud not reachable.");
        updateConnectionIndicator();
        return false;
      }

      try {
        const { error: delError } = await supabaseClient
          .from("evaluations")
          .delete()
          .eq("group_name", op.group_name)
          .eq("student", op.student)
          .eq("zone", op.zone)
          .eq("task", op.task);

        if (delError) throw delError;

        const { error: insError } = await supabaseClient.from("evaluations").insert(op);
        if (insError) throw insError;

        if (!isRetry) setMessage("Saved.");
        updateConnectionIndicator();
        return true;
      } catch (e) {
        enqueueOp(op);
        if (!isRetry) {
          const msg = e && e.message ? e.message : String(e);
          setMessage("Saved locally, cloud error: " + msg, true);
        }
        // if a cloud request failed, mark cloud unreachable until next refresh
        cloudReachable = false;
        updateConnectionIndicator();
        return false;
      }
    }

    async function processQueue() {
      const queue = loadQueue();
      if (queue.length === 0) {
        updateConnectionIndicator();
        return;
      }

      // check reachability again before trying
      await refreshConnectivity();
      if (!cloudReachable) return;

      const remaining = [];
      setMessage("Syncing offline changes...");
      connectionRightEl.textContent = "Syncing…";

      for (const op of queue) {
        const ok = await trySaveToSupabase(op, true);
        if (!ok) remaining.push(op);
      }

      saveQueue(remaining);

      if (remaining.length === 0) {
        setMessage("Offline changes synced.");
      } else {
        setMessage("Some changes still saved locally. Will retry.", true);
      }
      updateConnectionIndicator();
    }

    // Populate dropdown from local first (never blocked)
    function refreshGroupSelectFromLocalOnly() {
      const groups = loadGroupList().slice().sort((a, b) => a.localeCompare(b));
      while (groupSelect.options.length > 1) groupSelect.remove(1);
      groups.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        groupSelect.appendChild(opt);
      });
    }

    async function refreshGroupSelectWithCloudIfPossible() {
      refreshGroupSelectFromLocalOnly();

      await refreshConnectivity();
      if (!cloudReachable) return;

      try {
        const { data: evalData } = await supabaseClient.from("evaluations").select("group_name");
        const { data: courseData } = await supabaseClient.from("courses").select("group_name,is_closed");

        const groupsSet = new Set(loadGroupList());
        if (evalData) evalData.forEach(r => r.group_name && groupsSet.add(r.group_name));
        if (courseData) courseData.forEach(r => r.group_name && groupsSet.add(r.group_name));

        const closed = new Set();
        if (courseData) courseData.filter(r => r.is_closed).forEach(r => closed.add(r.group_name));

        const merged = Array.from(groupsSet).filter(n => !closed.has(n)).sort((a, b) => a.localeCompare(b));
        saveGroupList(merged);

        refreshGroupSelectFromLocalOnly();
      } catch {
        // keep local list
      }
    }

    function forceTableReflow() {
      tableContainer.scrollLeft = 0;
      const prev = tableContainer.style.transform;
      tableContainer.style.transform = "translateZ(0)";
      void tableContainer.offsetHeight;
      tableContainer.style.transform = prev || "";
      requestAnimationFrame(() => { void tableContainer.offsetHeight; });
    }

    function renderTable() {
      const groupName = groupNameInput.value.trim();

      if (!groupName) {
        setMessage("Enter a group name first.", true);
        return;
      }
      if (currentStudents.length === 0) {
        setMessage("Enter at least one student.", true);
        return;
      }

      let html = "<table>";

      html += "<tr><th class='task-col'>Task</th>";
      currentStudents.forEach(student => {
        html += `<th class="student-group-header" colspan="${STATUSES.length}">${student}</th>`;
      });
      html += "</tr>";

      html += "<tr><th class='task-col'></th>";
      currentStudents.forEach(() => {
        STATUSES.forEach(status => {
          html += `<th class="status-header" data-status="${status}">${status}</th>`;
        });
      });
      html += "</tr>";

      let lastZone = null;

      TASKS.forEach(task => {
        if (task.zone !== lastZone) {
          html += `<tr class="zone-row zone-row-${task.zone}">`;
          html += `<th class="zone-header task-col">Zone ${task.zone}</th>`;
          currentStudents.forEach(student => {
            html += `<th class="zone-header student-group-header" colspan="${STATUSES.length}">${student}</th>`;
          });
          html += "</tr>";
          lastZone = task.zone;
        }

        html += `<tr><td class="task-col">${task.label}</td>`;
        currentStudents.forEach(student => {
          STATUSES.forEach(status => {
            html += `
              <td class="status-cell" data-status="${status}">
                <div class="status-inner"
                     data-student="${encodeURIComponent(student)}"
                     data-zone="${task.zone}"
                     data-task="${encodeURIComponent(task.label)}"
                     data-status="${status}">
                </div>
              </td>`;
          });
        });
        html += "</tr>";
      });

      html += "</table>";
      tableContainer.innerHTML = html;

      document.querySelectorAll(".status-inner").forEach(el => el.addEventListener("click", onStatusClick));
      requestAnimationFrame(() => forceTableReflow());
    }

    async function onStatusClick(event) {
      const el = event.currentTarget;
      const student = decodeURIComponent(el.dataset.student);
      const zone = parseInt(el.dataset.zone, 10);
      const taskLabel = decodeURIComponent(el.dataset.task);
      const status = el.dataset.status;
      const groupName = groupNameInput.value.trim();

      const selectorAll =
        `.status-inner[data-student="${encodeURIComponent(student)}"]` +
        `[data-zone="${zone}"][data-task="${encodeURIComponent(taskLabel)}"]`;

      document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
      el.classList.add("selected");

      updateLocalState(groupName, student, zone, taskLabel, status);

      const op = { group_name: groupName, student, zone, task: taskLabel, status };
      await trySaveToSupabase(op);

      requestAnimationFrame(() => forceTableReflow());
    }

    async function loadSavedMarks() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) return;

      // Local first
      document.querySelectorAll(".status-inner").forEach(node => node.classList.remove("selected"));
      applyLocalStateToUI(groupName);

      // Then try cloud merge if reachable
      await refreshConnectivity();
      if (!cloudReachable) {
        setMessage("Loaded local marks. Cloud not reachable.");
        return;
      }

      await processQueue();

      const { data, error } = await supabaseClient
        .from("evaluations")
        .select("*")
        .eq("group_name", groupName);

      if (error) {
        setMessage("Loaded local marks. Cloud load failed.", true);
        return;
      }

      const localState = loadGroupState(groupName);
      const mergedState = { ...localState };

      (data || []).forEach(row => {
        const key = localKey(row.student, row.zone, row.task);
        if (mergedState[key] == null) mergedState[key] = row.status;
      });

      saveGroupState(groupName, mergedState);

      document.querySelectorAll(".status-inner").forEach(node => node.classList.remove("selected"));
      applyLocalStateToUI(groupName);

      setMessage("Loaded. Local marks kept where present.");
    }

    function exportCurrentGroupToCSV() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) {
        setMessage("Enter a group name before exporting.", true);
        return;
      }

      const state = loadGroupState(groupName);
      const entries = Object.entries(state);
      if (entries.length === 0) {
        setMessage("No local marks found for this group to export.", true);
        return;
      }

      const headers = ["group_name", "student", "zone", "task", "status"];
      const lines = [headers.join(",")];

      entries.forEach(([key, status]) => {
        const [student, zone, task] = key.split("|");
        const rowObj = { group_name: groupName, student, zone, task, status };

        const values = headers.map(h => {
          let val = rowObj[h];
          if (val == null) val = "";
          val = String(val).replace(/"/g, '""');
          if (val.search(/[",\n]/) !== -1) val = '"' + val + '"';
          return val;
        });

        lines.push(values.join(","));
      });

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = `snowboard_assessment_${groupName.replace(/\s+/g, "_")}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setMessage("CSV exported from local data.");
    }

    document.getElementById("applyLayoutBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();

      if (!groupName) { setMessage("Enter a group name first.", true); return; }
      if (currentStudents.length === 0) { setMessage("Enter at least one student.", true); return; }

      saveRoster(groupName, currentStudents);
      registerGroupName(groupName);
      refreshGroupSelectFromLocalOnly();

      renderTable();
      clearMessage();
      applyLocalStateToUI(groupName);

      refreshConnectivity(); // indicator only
    });

    document.getElementById("loadBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();
      if (groupName && currentStudents.length > 0) {
        saveRoster(groupName, currentStudents);
        registerGroupName(groupName);
        refreshGroupSelectFromLocalOnly();
      }
      renderTable();
      loadSavedMarks();
    });

    exportBtn.addEventListener("click", exportCurrentGroupToCSV);

    useGroupBtn.addEventListener("click", () => {
      const selectedGroup = groupSelect.value;
      if (!selectedGroup) {
        setMessage("Select a saved group first.", true);
        return;
      }

      groupNameInput.value = selectedGroup;

      const roster = loadRoster(selectedGroup);
      if (roster.length > 0) {
        studentsInput.value = roster.join(", ");
      }

      currentStudents = parseStudents();
      renderTable();
      loadSavedMarks();

      refreshConnectivity();
    });

    // iOS page restore: refresh indicator, force reflow
    window.addEventListener("pageshow", () => {
      refreshGroupSelectFromLocalOnly();
      refreshConnectivity();
      requestAnimationFrame(() => forceTableReflow());
    });

    window.addEventListener("orientationchange", () => requestAnimationFrame(() => forceTableReflow()));
    window.addEventListener("resize", () => requestAnimationFrame(() => forceTableReflow()));

    // Init
    refreshGroupSelectFromLocalOnly();
    currentStudents = parseStudents();
    renderTable();
    refreshConnectivity();
  </script>
</body>
</html>
