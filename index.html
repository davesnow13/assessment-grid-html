<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#f4f6f8;
      --border:#111;
      --muted:#555;
      --ok:#1b5e20;
      --bad:#b00020;
      --z1:#e3f2fd;
      --z2:#e8f5e9;
      --z3:#fff8e1;

      /* Layout knobs (mobile first) */
      --task-col-min: 210px;
      --task-col-max: 44vw;   /* stop it taking 75% on portrait */
      --box-size: 42px;
      --box-radius: 8px;
    }

    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: var(--bg);
      margin: 0;
    }

    h1{
      margin: 0 0 6px 0;
      font-size: 2.2rem;
      line-height: 1.05;
    }

    .small{
      font-size: 0.95rem;
      color: var(--muted);
      margin-bottom: 12px;
      max-width: 1100px;
    }

    .controls{
      margin: 12px 0 14px 0;
      display:flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label{
      font-size: 0.95rem;
      font-weight: 600;
    }

    input[type="text"], textarea, select{
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #c9d1d9;
      font-size: 0.95rem;
      background: #fff;
      min-width: 260px;
    }

    textarea{
      min-width: 420px;
      min-height: 44px;
      resize: vertical;
    }

    button{
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color:#fff;
      cursor:pointer;
      font-size: 0.95rem;
      font-weight: 700;
    }

    button.secondary{
      background:#5b636a;
      border-color:#4a5056;
    }

    button:disabled{
      opacity: .55;
      cursor: default;
    }

    .pill{
      border: 1px solid #c9d1d9;
      background:#fff;
      border-radius: 12px;
      padding: 10px 12px;
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      width: 100%;
      max-width: 1100px;
    }

    .pill .dot{
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: #aaa;
      flex: 0 0 auto;
    }
    .pill.online .dot{ background:#2e7d32; }
    .pill.offline .dot{ background:#c62828; }

    .pill strong{
      font-weight: 800;
    }

    #statusMsg{
      margin-top: 8px;
      font-size: 0.95rem;
      font-weight: 700;
    }
    #statusMsg.ok{ color: var(--ok); }
    #statusMsg.bad{ color: var(--bad); }

    #gridWrap{
      margin-top: 12px;
      border: 3px solid var(--border);
      background: #fff;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      max-width: 100%;
    }

    table{
      border-collapse: collapse;
      width: max-content;  /* allow horizontal scroll */
      min-width: 100%;
      table-layout: fixed;
    }

    th, td{
      border: 3px solid var(--border);
      padding: 10px 10px;
      font-size: 1.05rem;
      vertical-align: middle;
      background: #fff;
    }

    thead th{
      background: #f2f2f2;
      font-size: 1.1rem;
      font-weight: 900;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 3;
    }

    /* Sticky left task column */
    th.task, td.task{
      position: sticky;
      left: 0;
      z-index: 4;
      text-align: left;
      background: #fff;
      width: clamp(var(--task-col-min), var(--task-col-max), 420px);
      min-width: clamp(var(--task-col-min), var(--task-col-max), 420px);
      max-width: clamp(var(--task-col-min), var(--task-col-max), 420px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Ensure sticky task header stays above other sticky headers */
    thead th.task{
      z-index: 6;
    }

    /* Participant name headers */
    th.part{
      min-width: 220px;
      max-width: 260px;
      z-index: 3;
    }

    /* Status columns per participant */
    th.subhead{
      font-size: 0.95rem;
      font-weight: 900;
      padding: 8px 0;
    }
    th.sub-inc{ background: #ffebee; }
    th.sub-con{ background: #fffde7; }
    th.sub-refi{ background: #e8f5e9; }

    td.cell{
      text-align: center;
      min-width: 70px;
      padding: 10px 6px;
    }
    td.cell.inc{ background: #ffebee; }
    td.cell.con{ background: #fffde7; }
    td.cell.refi{ background: #e8f5e9; }

    .box{
      width: var(--box-size);
      height: var(--box-size);
      border-radius: var(--box-radius);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #9aa1a8;
      background: #e9ecef;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font-size: 1.4rem;
      font-weight: 900;
      line-height: 1;
    }
    .box.on{
      border-color: #2e7d32;
      background: #2e7d32;
      color: #fff;
    }

    /* Zone rows */
    tr.zone-row td{
      font-weight: 900;
      font-size: 1.15rem;
    }
    tr.zone-row td.task{
      white-space: normal;
      line-height: 1.1;
    }
    tr.zone-row.zone1 td{ background: var(--z1); }
    tr.zone-row.zone2 td{ background: var(--z2); }
    tr.zone-row.zone3 td{ background: var(--z3); }

    .zone-title{
      display:flex;
      flex-direction: column;
      gap: 2px;
    }
    .zone-title small{
      font-weight: 800;
      font-size: 0.9rem;
      color:#222;
      opacity: 0.85;
    }

    .infoBtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width: 26px;
  height: 26px;
  border-radius: 999px;
  border: 2px solid #333;
  background: #fff;

  /* Force the "i" to render visibly on iOS/Safari */
  color: #111;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  font-weight: 900;
  font-size: 16px;
  line-height: 1;

  cursor:pointer;
  margin-left: 8px;
  flex: 0 0 auto;
  padding: 0;
}

    dialog{
      border: 2px solid #222;
      border-radius: 12px;
      padding: 14px;
      max-width: 780px;
      width: calc(100% - 24px);
    }
    dialog::backdrop{
      background: rgba(0,0,0,.35);
    }
    .dlgTitle{
      font-weight: 900;
      font-size: 1.2rem;
      margin: 0 0 8px 0;
    }
    .dlgBody{
      white-space: pre-wrap;
      font-size: 1rem;
      line-height: 1.35;
      color:#111;
    }
    .dlgActions{
      display:flex;
      justify-content:flex-end;
      margin-top: 12px;
      gap: 10px;
    }

    @media (max-width: 520px){
      input[type="text"], select{ min-width: 220px; }
      textarea{ min-width: 220px; }
      :root{
        --task-col-min: 180px;
        --task-col-max: 52vw;
        --box-size: 40px;
      }
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and synced to Supabase automatically when possible. You can also export to CSV.
  </div>

  <div class="controls">
    <label>Group name:</label>
    <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />

    <label>Students (comma-separated):</label>
    <input id="studentsInput" type="text" placeholder="Example: 12 Albert, 3 Reuben, 25 Benedict OR Albert, Reuben, Benedict" style="min-width:420px;" />

    <button id="applyBtn">Apply layout</button>
  </div>

  <div class="controls">
    <button id="loadLocalBtn">Load saved marks</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
    <button id="syncBtn" class="secondary">Sync now</button>
  </div>

  <div class="controls">
    <label>Saved groups (local):</label>
    <select id="savedGroups">
      <option value="">Select a saved group</option>
    </select>
    <button id="useGroupBtn" class="secondary">Use group</button>

    <label>Cloud groups:</label>
    <select id="cloudGroups">
      <option value="">Select a cloud group</option>
    </select>
    <button id="pullCloudBtn" class="secondary">Pull from cloud</button>
  </div>

  <div class="pill" id="connPill">
    <span class="dot"></span>
    <span id="connText"><strong>Status:</strong> Checking…</span>
    <span style="margin-left:auto;" id="syncText"></span>
  </div>

  <div id="statusMsg"></div>

  <div id="gridWrap"></div>

  <dialog id="infoDialog">
    <div class="dlgTitle" id="dlgTitle"></div>
    <div class="dlgBody" id="dlgBody"></div>
    <div class="dlgActions">
      <button id="dlgClose" class="secondary" type="button">Close</button>
    </div>
  </dialog>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // -----------------------------
    // Supabase config
    // -----------------------------
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // -----------------------------
    // New zone/task definitions
    // -----------------------------
    const ZONES = [
      {
        zone: 1,
        title: "Zone 1",
        subtitle: "FLATS AND MAGIC CARPET AREA",
        colorClass: "zone1",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        info: {
          "Possible Constraints": [
            "Glide with reduced space or toward a target marker.",
            "Perform skating tasks with a variable snow surface (slightly packed or soft).",
            "Skating around obstacles (example: cones, stubbies).",
            "Use minor slope gradient to encourage longer glide or speed awareness."
          ],
          "Evaluation Focus": [
            "Balance and coordination while gliding",
            "Smooth push and glide transitions",
            "Controlled direction and stopping",
            "Awareness of surrounding space and other riders"
          ]
        }
      },
      {
        zone: 2,
        title: "Zone 2",
        subtitle: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        colorClass: "zone2",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        info: {
          "Possible variations": [
            "Perform a controlled stop during a sideslip or traverse.",
            "Link multiple turns with slight changes in snow texture or slope pitch.",
            "Ride both toe and heel sides in the same run.",
            "Follow a marked path or cone line to encourage directional awareness."
          ],
          "Evaluation Focus": [
            "Smooth loading and unloading of the magic carpet",
            "Balanced posture while standing on both edges",
            "Controlled side slips without abrupt stops",
            "Stable traverses across the slope",
            "Linked turns showing direction and speed control"
          ]
        }
      },
      {
        zone: 3,
        title: "Zone 3",
        subtitle: "FLAGGED GREEN RUN",
        colorClass: "zone3",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        info: {
          "Evaluation Focus": [
            "Continuous linked turns along the flagged path",
            "Speed managed through turn shape, not braking",
            "Controlled edge release and engagement",
            "Flow maintained through variable turn timing",
            "Adaptability to terrain, snow, and surrounding traffic"
          ]
        }
      }
    ];

    // -----------------------------
    // UI elements
    // -----------------------------
    const groupNameEl = document.getElementById("groupName");
    const studentsInputEl = document.getElementById("studentsInput");
    const applyBtn = document.getElementById("applyBtn");

    const loadLocalBtn = document.getElementById("loadLocalBtn");
    const exportBtn = document.getElementById("exportBtn");
    const syncBtn = document.getElementById("syncBtn");

    const savedGroupsEl = document.getElementById("savedGroups");
    const useGroupBtn = document.getElementById("useGroupBtn");

    const cloudGroupsEl = document.getElementById("cloudGroups");
    const pullCloudBtn = document.getElementById("pullCloudBtn");

    const statusMsgEl = document.getElementById("statusMsg");
    const gridWrap = document.getElementById("gridWrap");

    const connPill = document.getElementById("connPill");
    const connText = document.getElementById("connText");
    const syncText = document.getElementById("syncText");

    const infoDialog = document.getElementById("infoDialog");
    const dlgTitle = document.getElementById("dlgTitle");
    const dlgBody = document.getElementById("dlgBody");
    const dlgClose = document.getElementById("dlgClose");

    // -----------------------------
    // State
    // -----------------------------
    let currentGroup = "";
    let participants = []; // [{key, label, bib, name}]
    let marks = {}; // marks[participantKey][zone][task] = "Inc"|"Con"|"Refi"|null
    let isCloudReachable = false;
    let lastSyncAt = null;

    // -----------------------------
    // Helpers
    // -----------------------------
    function setMsg(text, ok = true){
      statusMsgEl.textContent = text;
      statusMsgEl.className = ok ? "ok" : "bad";
    }
    function clearMsg(){
      statusMsgEl.textContent = "";
      statusMsgEl.className = "";
    }

    function normalizeSpaces(s){
      return String(s || "").trim().replace(/\s+/g, " ");
    }

    function parseParticipants(raw){
      // Accept:
      // "12 Albert, 3 Reuben, 25 Benedict" (bib + name)
      // OR "Albert, Reuben, Benedict" (names only)
      const items = String(raw || "")
        .split(",")
        .map(x => normalizeSpaces(x))
        .filter(Boolean);

      const parsed = items.map((item, idx) => {
        // match "number name"
        const m = item.match(/^(\d+)\s+(.+)$/);
        if (m){
          const bib = parseInt(m[1], 10);
          const name = normalizeSpaces(m[2]);
          return {
            key: `bib:${bib}`,
            label: `${bib} ${name}`,
            bib,
            name
          };
        }
        // name only
        const nameOnly = item;
        return {
          key: `name:${nameOnly.toLowerCase()}`,
          label: nameOnly,
          bib: null,
          name: nameOnly
        };
      });

      // Sort rule:
      // If ANY bib exists, sort bib participants by bib asc, then names without bib after (alpha)
      const hasAnyBib = parsed.some(p => Number.isFinite(p.bib));
      if (hasAnyBib){
        const withBib = parsed.filter(p => Number.isFinite(p.bib)).sort((a,b) => a.bib - b.bib);
        const noBib = parsed.filter(p => !Number.isFinite(p.bib)).sort((a,b) => a.label.localeCompare(b.label));
        return [...withBib, ...noBib];
      }

      // No bibs: sort alpha
      return parsed.sort((a,b) => a.label.localeCompare(b.label));
    }

    function ensureMarksShape(){
      participants.forEach(p => {
        if (!marks[p.key]) marks[p.key] = {};
        ZONES.forEach(z => {
          if (!marks[p.key][z.zone]) marks[p.key][z.zone] = {};
          z.tasks.forEach(t => {
            if (!(t in marks[p.key][z.zone])) marks[p.key][z.zone][t] = null;
          });
        });
      });
    }

    function localKey(group){
      return `sb_assessment_${group}`;
    }

    function saveLocal(){
      if (!currentGroup) return;
      const payload = {
        group_name: currentGroup,
        participants,
        marks,
        updated_at: new Date().toISOString()
      };
      localStorage.setItem(localKey(currentGroup), JSON.stringify(payload));
      refreshLocalGroupsDropdown();
    }

    function loadLocal(group){
      const raw = localStorage.getItem(localKey(group));
      if (!raw) return null;
      try{
        return JSON.parse(raw);
      }catch{
        return null;
      }
    }

    function refreshLocalGroupsDropdown(){
      // rebuild from localStorage keys
      const keys = Object.keys(localStorage).filter(k => k.startsWith("sb_assessment_"));
      const groups = keys.map(k => k.replace("sb_assessment_", ""));
      groups.sort((a,b) => a.localeCompare(b));

      const prev = savedGroupsEl.value;

      savedGroupsEl.innerHTML = `<option value="">Select a saved group</option>`;
      groups.forEach(g => {
        const opt = document.createElement("option");
        opt.value = g;
        opt.textContent = g;
        savedGroupsEl.appendChild(opt);
      });

      if (groups.includes(prev)) savedGroupsEl.value = prev;
    }

    function openInfoDialog(zoneObj){
      const parts = [];
      Object.entries(zoneObj.info || {}).forEach(([k, arr]) => {
        parts.push(`${k}\n${arr.map(x => "• " + x).join("\n")}`);
      });

      dlgTitle.textContent = `${zoneObj.title}: Info`;
      dlgBody.textContent = parts.join("\n\n");
      infoDialog.showModal();
    }

    function statusToLong(s){
      if (s === "Inc") return "Inconsistent";
      if (s === "Con") return "Consistent";
      if (s === "Refi") return "Refined";
      return s || "";
    }

    // -----------------------------
    // Rendering
    // -----------------------------
    function renderGrid(){
      if (!currentGroup || participants.length === 0){
        gridWrap.innerHTML = "";
        return;
      }

      ensureMarksShape();

      let html = "<table>";

      // Header row 1: Task + participant names (colspan 3 each)
      html += "<thead>";
      html += "<tr>";
      html += `<th class="task">Task</th>`;
      participants.forEach(p => {
        html += `<th class="part" colspan="3">${escapeHtml(p.label)}</th>`;
      });
      html += "</tr>";

      // Header row 2: subheaders Inc/Con/Refi
      html += "<tr>";
      html += `<th class="task"></th>`;
      participants.forEach(() => {
        html += `<th class="subhead sub-inc">Inc</th>`;
        html += `<th class="subhead sub-con">Con</th>`;
        html += `<th class="subhead sub-refi">Refi</th>`;
      });
      html += "</tr>";
      html += "</thead>";

      html += "<tbody>";

      // Zone blocks
      ZONES.forEach(z => {
        // Zone row (with info button in task column only)
        html += `<tr class="zone-row ${z.colorClass}" data-zone="${z.zone}">`;
        html += `<td class="task">
          <div class="zone-title">
            <div>${escapeHtml(z.title)} <button class="infoBtn" type="button" data-info-zone="${z.zone}" aria-label="Info">i</button></div>
            <small>${escapeHtml(z.subtitle)}</small>
          </div>
        </td>`;
        participants.forEach(p => {
          html += `<td colspan="3" style="text-align:center;font-weight:900;">${escapeHtml(p.label)}</td>`;
        });
        html += "</tr>";

        // Task rows
        z.tasks.forEach(task => {
          html += `<tr data-zone="${z.zone}" data-task="${escapeAttr(task)}">`;
          html += `<td class="task">${escapeHtml(task)}</td>`;

          participants.forEach(p => {
            const val = marks?.[p.key]?.[z.zone]?.[task] || null;

            html += renderCell(p.key, z.zone, task, "Inc", val);
            html += renderCell(p.key, z.zone, task, "Con", val);
            html += renderCell(p.key, z.zone, task, "Refi", val);
          });

          html += "</tr>";
        });
      });

      html += "</tbody></table>";

      gridWrap.innerHTML = html;

      // bind info buttons
      gridWrap.querySelectorAll("[data-info-zone]").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const zoneNum = parseInt(e.currentTarget.getAttribute("data-info-zone"), 10);
          const zoneObj = ZONES.find(x => x.zone === zoneNum);
          if (zoneObj) openInfoDialog(zoneObj);
        });
      });

      // bind mark taps
      gridWrap.querySelectorAll("[data-mark]").forEach(btn => {
        btn.addEventListener("click", onMarkClick);
      });
    }

    function renderCell(participantKey, zone, task, status, currentVal){
      const isOn = currentVal === status;
      const cls = status === "Inc" ? "inc" : status === "Con" ? "con" : "refi";
      const onCls = isOn ? "on" : "";
      const check = isOn ? "✓" : "";
      const payload = encodeURIComponent(JSON.stringify({ participantKey, zone, task, status }));
      return `
        <td class="cell ${cls}">
          <div class="box ${onCls}" data-mark="${payload}" role="button" tabindex="0" aria-label="${status}">
            ${check}
          </div>
        </td>
      `;
    }

    function onMarkClick(e){
      const box = e.currentTarget;
      const payload = JSON.parse(decodeURIComponent(box.getAttribute("data-mark")));
      const { participantKey, zone, task, status } = payload;

      const current = marks?.[participantKey]?.[zone]?.[task] || null;
      const next = (current === status) ? null : status;

      marks[participantKey][zone][task] = next;

      saveLocal();
      renderGrid();

      // Do not force scroll resets. The user complained about this previously.
      // We intentionally do NOT scroll back or re-center anything.
    }

    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }
    function escapeAttr(s){
      return escapeHtml(s).replace(/"/g, "&quot;");
    }

    // -----------------------------
    // Cloud sync: participant_map + evaluations
    // -----------------------------
    async function checkCloudReachable(){
      // quick ping: attempt lightweight select on courses
      try{
        const { error } = await db.from("courses").select("group_name").limit(1);
        isCloudReachable = !error;
      }catch{
        isCloudReachable = false;
      }
      renderConnPill();
      return isCloudReachable;
    }

    function renderConnPill(){
      connPill.classList.remove("online","offline");
      if (isCloudReachable){
        connPill.classList.add("online");
        connText.innerHTML = "<strong>Online:</strong> cloud is reachable.";
      }else{
        connPill.classList.add("offline");
        connText.innerHTML = "<strong>Offline:</strong> cloud not reachable. Using local storage.";
      }
      syncText.textContent = lastSyncAt ? ("Synced " + new Date(lastSyncAt).toLocaleString()) : "";
    }

    async function upsertCourseParticipantMap(){
      // Save participant_map in courses table for consistent ordering across devices
      // participant_map JSON structure:
      // { version: 1, participants: [{bib, name, label}], updated_at }
      const participant_map = {
        version: 1,
        participants: participants.map(p => ({
          bib: p.bib,
          name: p.name,
          label: p.label,
          key: p.key
        })),
        updated_at: new Date().toISOString()
      };

      const { error } = await db.from("courses").upsert(
        [{
          group_name: currentGroup,
          participant_map,
          is_closed: false
        }],
        { onConflict: "group_name" }
      );

      if (error) throw error;
    }

    function flattenEvaluationsForCloud(){
      // Convert marks -> evaluations rows
      // Table: evaluations columns expected:
      // group_name, student, zone, task, status
      const rows = [];
      participants.forEach(p => {
        ZONES.forEach(z => {
          z.tasks.forEach(task => {
            const status = marks?.[p.key]?.[z.zone]?.[task] || null;
            if (status){
              rows.push({
                group_name: currentGroup,
                student: p.label,   // store display label in student (works for bibs and names)
                zone: z.zone,
                task,
                status
              });
            }
          });
        });
      });
      return rows;
    }

    async function syncToCloud(){
      clearMsg();

      if (!currentGroup){
        setMsg("Enter a group name first.", false);
        return;
      }

      const ok = await checkCloudReachable();
      if (!ok){
        setMsg("Cloud not reachable. Saved locally only.", false);
        return;
      }

      setMsg("Syncing to cloud…", true);

      try{
        // 1) Save participant_map to courses
        await upsertCourseParticipantMap();

        // 2) Replace evaluations rows for this group
        // Delete existing rows first (simple approach)
        const del = await db.from("evaluations").delete().eq("group_name", currentGroup);
        if (del.error) throw del.error;

        // Insert only marked rows (keeps table clean)
        const rows = flattenEvaluationsForCloud();
        if (rows.length > 0){
          const ins = await db.from("evaluations").insert(rows);
          if (ins.error) throw ins.error;
        }

        lastSyncAt = new Date().toISOString();
        renderConnPill();
        setMsg("Synced to cloud.", true);
      }catch(err){
        console.error(err);
        setMsg("Could not sync to cloud. Saved locally only.", false);
      }
    }

    async function refreshCloudGroupsDropdown(){
      cloudGroupsEl.innerHTML = `<option value="">Select a cloud group</option>`;
      const ok = await checkCloudReachable();
      if (!ok) return;

      const { data, error } = await db
        .from("courses")
        .select("group_name")
        .order("group_name", { ascending: true });

      if (error){
        console.error(error);
        return;
      }

      (data || []).forEach(r => {
        if (!r.group_name) return;
        const opt = document.createElement("option");
        opt.value = r.group_name;
        opt.textContent = r.group_name;
        cloudGroupsEl.appendChild(opt);
      });
    }

    async function pullFromCloud(){
      clearMsg();
      const g = cloudGroupsEl.value;
      if (!g){
        setMsg("Select a cloud group first.", false);
        return;
      }

      const ok = await checkCloudReachable();
      if (!ok){
        setMsg("Cloud not reachable.", false);
        return;
      }

      setMsg("Pulling from cloud…", true);

      try{
        // 1) Get participant_map
        const courseRes = await db
          .from("courses")
          .select("participant_map")
          .eq("group_name", g)
          .maybeSingle();

        if (courseRes.error && courseRes.error.code !== "PGRST116"){
          throw courseRes.error;
        }

        let pulledParticipants = null;
        const pm = courseRes.data?.participant_map;

        if (pm && pm.participants && Array.isArray(pm.participants)){
          pulledParticipants = pm.participants.map(x => ({
            key: x.key || (Number.isFinite(x.bib) ? `bib:${x.bib}` : `name:${String(x.name||x.label||"").toLowerCase()}`),
            label: x.label || (Number.isFinite(x.bib) ? `${x.bib} ${x.name}` : (x.name || "")),
            bib: Number.isFinite(x.bib) ? x.bib : null,
            name: x.name || (x.label || "")
          }));
        }

        // 2) Pull evaluations
        const evalRes = await db
          .from("evaluations")
          .select("student, zone, task, status")
          .eq("group_name", g)
          .order("student", { ascending: true })
          .order("zone", { ascending: true });

        if (evalRes.error) throw evalRes.error;

        // If no participant_map exists, derive participant list from student names in evaluations
        if (!pulledParticipants){
          const set = new Set();
          (evalRes.data || []).forEach(r => { if (r.student) set.add(r.student); });
          pulledParticipants = Array.from(set).sort((a,b)=>a.localeCompare(b)).map(name => ({
            key: `name:${name.toLowerCase()}`,
            label: name,
            bib: null,
            name
          }));
        }

        // Build marks object from pulled evaluations
        const newMarks = {};
        pulledParticipants.forEach(p => { newMarks[p.key] = {}; });
        pulledParticipants.forEach(p => {
          ZONES.forEach(z => {
            if (!newMarks[p.key][z.zone]) newMarks[p.key][z.zone] = {};
            z.tasks.forEach(t => newMarks[p.key][z.zone][t] = null);
          });
        });

        // map by student label
        const labelToKey = new Map(pulledParticipants.map(p => [p.label, p.key]));
        (evalRes.data || []).forEach(r => {
          const k = labelToKey.get(r.student);
          if (!k) return;
          if (!newMarks[k]) return;
          if (!newMarks[k][r.zone]) newMarks[k][r.zone] = {};
          newMarks[k][r.zone][r.task] = r.status;
        });

        // Apply to app state
        currentGroup = g;
        groupNameEl.value = g;

        participants = pulledParticipants;
        marks = newMarks;
        ensureMarksShape();

        // Update students input display
        studentsInputEl.value = participants.map(p => p.label).join(", ");

        saveLocal();
        renderGrid();

        setMsg("Pulled from cloud and saved locally.", true);
      }catch(err){
        console.error(err);
        setMsg("Could not pull from cloud.", false);
      }
    }

    // -----------------------------
    // CSV export
    // -----------------------------
    function exportCsv(){
      if (!currentGroup || participants.length === 0){
        setMsg("Nothing to export.", false);
        return;
      }

      const headers = ["group_name","student","zone","task","status"];
      const lines = [headers.join(",")];

      participants.forEach(p => {
        ZONES.forEach(z => {
          z.tasks.forEach(task => {
            const status = marks?.[p.key]?.[z.zone]?.[task] || "";
            const row = [
              currentGroup,
              p.label,
              String(z.zone),
              task,
              statusToLong(status)
            ].map(v => {
              const s = String(v ?? "").replace(/"/g,'""');
              return (/[",\n]/.test(s)) ? `"${s}"` : s;
            });
            lines.push(row.join(","));
          });
        });
      });

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `snowboard_assessment_${currentGroup.replace(/\s+/g,"_")}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setMsg("CSV exported.", true);
    }

    // -----------------------------
    // Event handlers
    // -----------------------------
    applyBtn.addEventListener("click", async () => {
      clearMsg();

      const g = normalizeSpaces(groupNameEl.value);
      const rawStudents = normalizeSpaces(studentsInputEl.value);

      if (!g){
        setMsg("Enter a group name.", false);
        return;
      }
      if (!rawStudents){
        setMsg("Enter at least one student.", false);
        return;
      }

      currentGroup = g;
      participants = parseParticipants(rawStudents);
      marks = marks || {};

      ensureMarksShape();
      saveLocal();
      renderGrid();

      setMsg("Layout applied. Marks saved locally.", true);

      // opportunistic cloud sync
      await syncToCloud();
      await refreshCloudGroupsDropdown();
    });

    loadLocalBtn.addEventListener("click", () => {
      clearMsg();
      if (!currentGroup){
        const maybe = savedGroupsEl.value;
        if (!maybe){
          setMsg("Select a local saved group or enter a group name.", false);
          return;
        }
        currentGroup = maybe;
        groupNameEl.value = maybe;
      }

      const loaded = loadLocal(currentGroup);
      if (!loaded){
        setMsg("No local data found for that group.", false);
        return;
      }

      currentGroup = loaded.group_name;
      groupNameEl.value = loaded.group_name;

      participants = loaded.participants || [];
      marks = loaded.marks || {};

      ensureMarksShape();
      studentsInputEl.value = participants.map(p => p.label).join(", ");

      renderGrid();
      setMsg("Loaded local marks.", true);
    });

    useGroupBtn.addEventListener("click", () => {
      clearMsg();
      const g = savedGroupsEl.value;
      if (!g){
        setMsg("Select a saved group first.", false);
        return;
      }

      const loaded = loadLocal(g);
      if (!loaded){
        setMsg("Could not load that saved group.", false);
        return;
      }

      currentGroup = loaded.group_name;
      groupNameEl.value = loaded.group_name;
      participants = loaded.participants || [];
      marks = loaded.marks || {};
      ensureMarksShape();
      studentsInputEl.value = participants.map(p => p.label).join(", ");
      renderGrid();

      setMsg("Loaded. Local marks kept where present.", true);
    });

    exportBtn.addEventListener("click", exportCsv);
    syncBtn.addEventListener("click", syncToCloud);

    pullCloudBtn.addEventListener("click", pullFromCloud);

    dlgClose.addEventListener("click", () => infoDialog.close());

    // -----------------------------
    // Init
    // -----------------------------
    refreshLocalGroupsDropdown();
    checkCloudReachable().then(refreshCloudGroupsDropdown);

    window.addEventListener("online", async () => {
      await checkCloudReachable();
      await refreshCloudGroupsDropdown();
    });
    window.addEventListener("offline", async () => {
      await checkCloudReachable();
    });
  </script>
</body>
</html>