<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment Grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: #f4f6f8;
    }

    h1 { margin-bottom: 4px; }

    .small { font-size: 0.85rem; color: #555; }

    .controls {
      margin: 12px 0 14px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label { font-size: 0.9rem; }

    input[type="text"], select {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 0.95rem;
      background: #fff;
    }

    button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color: white;
      cursor: pointer;
      font-size: 0.95rem;
    }

    button.secondary {
      background: #5b636a;
      border-color: #4a5056;
    }

    button:disabled { opacity: 0.6; cursor: default; }

    /* Connection status banner */
    #connectionStatus {
      margin: 10px 0 10px 0;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #c9d1d9;
      background: #ffffff;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }

    #connectionStatus .left {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
    }

    #connectionStatus .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      flex: 0 0 auto;
      border: 1px solid rgba(0,0,0,0.2);
    }

    #connectionStatus .text {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #connectionStatus .right {
      flex: 0 0 auto;
      font-size: 0.85rem;
      color: #555;
      white-space: nowrap;
    }

    #connectionStatus.online .dot { background: #2e7d32; }
    #connectionStatus.online { border-color: #b7dfc2; background: #f1fbf3; }

    #connectionStatus.offline .dot { background: #616161; }
    #connectionStatus.offline { border-color: #d0d0d0; background: #f6f6f6; }

    /* Horizontal scroll wrapper */
    #tableContainer {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      background: white;
      min-width: 760px;
    }

    th, td {
      border: 2px solid #000;
      padding: 6px 4px;
      text-align: center;
      font-size: 0.85rem;
    }

    /* Sticky first column for task names */
    th.task-col,
    td.task-col {
      text-align: left;
      min-width: 90px;
      max-width: 140px;
      background: #f9fbfd;
      position: sticky;
      left: 0;
      z-index: 3;
      white-space: normal;
      word-break: break-word;
      padding-left: 6px;
      padding-right: 6px;
      line-height: 1.15;
    }

    th.zone-header {
      text-align: left;
      font-size: 0.95rem;
      position: sticky;
      left: 0;
      z-index: 4;
    }

    th.student-group-header { background: #d9dde0; }

    th.status-header { font-size: 0.75rem; }

    /* Zone row background colors */
    .zone-row-1 th { background: #e3f2fd; }
    .zone-row-2 th { background: #e8f5e9; }
    .zone-row-3 th { background: #fff3e0; }

    /* Zone header row layout */
    .zone-title-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: space-between;
    }
    .zone-title-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }
    .zone-title-left .zone-title {
      font-weight: 700;
      line-height: 1.1;
    }
    .zone-title-left .zone-subtitle {
      font-weight: 500;
      font-size: 0.78rem;
      color: #333;
      line-height: 1.1;
    }

    /* Info button (the “I” in a circle) */
    .info-btn {
      width: 28px;
      height: 28px;
      border-radius: 999px;
      border: 1px solid #333;
      background: rgba(255,255,255,0.75);
      color: #111;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex: 0 0 auto;
      user-select: none;
    }
    .info-btn:active { transform: scale(0.98); }

    /* Base status cell */
    .status-cell { background: #f5f5f5; }

    .status-inner {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #e9ecef;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .status-inner.selected::after {
      content: "✓";
      color: white;
      font-size: 0.8rem;
    }

    /* Inc = red */
    .status-header[data-status="Inc"],
    .status-cell[data-status="Inc"] { background: #ffebee; }
    .status-inner[data-status="Inc"].selected { background: #c62828; border-color: #8e0000; }

    /* Con = yellow */
    .status-header[data-status="Con"],
    .status-cell[data-status="Con"] { background: #fffde7; }
    .status-inner[data-status="Con"].selected { background: #f9a825; border-color: #c17900; }

    /* Refi = green */
    .status-header[data-status="Refi"],
    .status-cell[data-status="Refi"] { background: #e8f5e9; }
    .status-inner[data-status="Refi"].selected { background: #2e7d32; border-color: #1b5e20; }

    .message { margin-top: 8px; font-size: 0.8rem; color: #444; }
    .error { color: #b00020; }
    .success { color: #1b5e20; }

    /* Info modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .modal-backdrop.open { display: flex; }

    .modal {
      width: 100%;
      max-width: 720px;
      background: #fff;
      border-radius: 12px;
      border: 1px solid #c9d1d9;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      overflow: hidden;
    }
    .modal-header {
      padding: 14px 16px;
      background: #f6f8fa;
      border-bottom: 1px solid #c9d1d9;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .modal-title {
      font-size: 1rem;
      font-weight: 700;
      line-height: 1.2;
    }
    .modal-close {
      border: 1px solid #4a5056;
      background: #5b636a;
      color: #fff;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .modal-body {
      padding: 14px 16px;
      font-size: 0.95rem;
      line-height: 1.35;
      color: #111;
    }
    .modal-section-title {
      margin-top: 8px;
      margin-bottom: 6px;
      font-weight: 700;
    }
    .modal ul {
      margin: 0 0 10px 18px;
      padding: 0;
    }
    .modal li { margin: 4px 0; }
    .modal .muted { color: #333; }

    @media (max-width: 600px) {
      th.task-col, td.task-col {
        min-width: 110px;
        max-width: 160px;
        font-size: 0.72rem;
        line-height: 1.15;
      }
      table { font-size: 0.75rem; }
      th, td { padding: 4px 2px; }
      .status-inner { width: 26px; height: 26px; }
      .info-btn { width: 30px; height: 30px; }
    }

    @media (pointer: coarse) {
      .status-inner { width: 30px; height: 30px; }
      th, td { padding-top: 6px; padding-bottom: 6px; }
    }
  </style>
</head>
<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and
    synced to Supabase automatically when possible. You can also export to CSV.
  </div>

  <div class="controls">
    <label>
      Group name:
      <input id="groupNameInput" type="text" placeholder="e.g. Lake Louise Group A" />
    </label>

    <label>
      Students:
      <input id="studentsInput" type="text" value="Reuben, Albert, Benedict" />
    </label>

    <button id="applyLayoutBtn">Apply layout</button>
    <button id="loadBtn">Load saved marks</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
  </div>

  <div class="controls">
    <label>
      Saved groups:
      <select id="groupSelect">
        <option value="">Select a saved group</option>
      </select>
    </label>
    <button id="useGroupBtn" class="secondary">Use group</button>
  </div>

  <div id="connectionStatus" class="offline" aria-live="polite">
    <div class="left">
      <span class="dot" aria-hidden="true"></span>
      <div class="text" id="connectionText">Checking cloud connection…</div>
    </div>
    <div class="right" id="connectionRight">—</div>
  </div>

  <div id="statusMsg" class="message"></div>
  <div id="tableContainer"></div>

  <!-- Info modal -->
  <div id="infoBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" role="document">
      <div class="modal-header">
        <div class="modal-title" id="infoTitle">Info</div>
        <button class="modal-close" id="infoCloseBtn" type="button">Close</button>
      </div>
      <div class="modal-body" id="infoBody"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const STATUSES = ["Inc", "Con", "Refi"];

    /**
     * UPDATED GRID DEFINITIONS (Zones, Tasks, and “Info” content)
     */
    const ZONES = [
      {
        zone: 1,
        title: "Zone 1",
        subtitle: "FLATS AND MAGIC CARPET AREA",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        info: {
          constraintsTitle: "Possible Constraints",
          constraints: [
            "Glide with reduced space or toward a target marker.",
            "Perform skating tasks with a variable snow surface (slightly packed or soft).",
            "Skating around obstacles (example: cones, stubbies).",
            "Use minor slope gradient to encourage longer glide or speed awareness."
          ],
          focusTitle: "Evaluation Focus",
          focus: [
            "Balance and coordination while gliding",
            "Smooth push and glide transitions",
            "Controlled direction and stopping",
            "Awareness of surrounding space and other riders"
          ]
        }
      },
      {
        zone: 2,
        title: "Zone 2",
        subtitle: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        info: {
          constraintsTitle: "Possible Variations",
          constraints: [
            "Perform a controlled stop during a sideslip or traverse.",
            "Link multiple turns with slight changes in snow texture or slope pitch.",
            "Ride both toe and heel sides in the same run.",
            "Follow a marked path or cone line to encourage directional awareness."
          ],
          focusTitle: "Evaluation Focus",
          focus: [
            "Smooth loading and unloading of the magic carpet",
            "Balanced posture while standing on both edges",
            "Controlled side slips without abrupt stops",
            "Stable traverses across the slope",
            "Linked turns showing direction and speed control"
          ]
        }
      },
      {
        zone: 3,
        title: "Zone 3",
        subtitle: "FLAGGED GREEN RUN",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        info: {
          constraintsTitle: "Evaluation Focus",
          constraints: [
            "Continuous linked turns along the flagged path",
            "Speed managed through turn shape, not braking",
            "Controlled edge release and engagement",
            "Flow maintained through variable turn timing",
            "Adaptability to terrain, snow, and surrounding traffic"
          ],
          focusTitle: "",
          focus: []
        }
      }
    ];

    const groupNameInput = document.getElementById("groupNameInput");
    const studentsInput = document.getElementById("studentsInput");
    const tableContainer = document.getElementById("tableContainer");
    const statusMsg = document.getElementById("statusMsg");
    const exportBtn = document.getElementById("exportBtn");
    const groupSelect = document.getElementById("groupSelect");
    const useGroupBtn = document.getElementById("useGroupBtn");

    const connectionStatusEl = document.getElementById("connectionStatus");
    const connectionTextEl = document.getElementById("connectionText");
    const connectionRightEl = document.getElementById("connectionRight");

    const infoBackdrop = document.getElementById("infoBackdrop");
    const infoTitle = document.getElementById("infoTitle");
    const infoBody = document.getElementById("infoBody");
    const infoCloseBtn = document.getElementById("infoCloseBtn");

    let currentStudents = [];

    const LOCAL_STATE_PREFIX = "assessmentGrid_state_";
    const LOCAL_QUEUE_KEY = "assessmentGrid_queue_v1";
    const LOCAL_GROUPS_KEY = "assessmentGrid_groups";
    const LOCAL_ROSTER_PREFIX = "assessmentGrid_roster_";

    let cloudReachable = false;

    function setMessage(text, isError = false) {
      statusMsg.textContent = text;
      statusMsg.className = "message " + (isError ? "error" : "success");
    }

    function clearMessage() {
      statusMsg.textContent = "";
      statusMsg.className = "message";
    }

    function parseStudents() {
      return studentsInput.value
        .split(",")
        .map(s => s.trim())
        .filter(s => s.length > 0);
    }

    function saveRoster(groupName, students) {
      try { localStorage.setItem(LOCAL_ROSTER_PREFIX + groupName, JSON.stringify(students)); } catch {}
    }

    function loadRoster(groupName) {
      try {
        const raw = localStorage.getItem(LOCAL_ROSTER_PREFIX + groupName);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed : [];
      } catch { return []; }
    }

    function loadGroupList() {
      try {
        const raw = localStorage.getItem(LOCAL_GROUPS_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }

    function saveGroupList(list) {
      try { localStorage.setItem(LOCAL_GROUPS_KEY, JSON.stringify(list)); } catch {}
    }

    function registerGroupName(groupName) {
      if (!groupName) return;
      const list = loadGroupList();
      if (!list.includes(groupName)) {
        list.push(groupName);
        saveGroupList(list);
      }
    }

    function localKey(student, zone, task) {
      return `${student}|${zone}|${task}`;
    }

    function loadGroupState(groupName) {
      if (!groupName) return {};
      try {
        const raw = localStorage.getItem(LOCAL_STATE_PREFIX + groupName);
        return raw ? JSON.parse(raw) : {};
      } catch { return {}; }
    }

    function saveGroupState(groupName, state) {
      if (!groupName) return;
      try { localStorage.setItem(LOCAL_STATE_PREFIX + groupName, JSON.stringify(state)); } catch {}
    }

    function updateLocalState(groupName, student, zone, task, status) {
      const key = localKey(student, zone, task);
      const state = loadGroupState(groupName);
      state[key] = status;
      saveGroupState(groupName, state);
      registerGroupName(groupName);

      const roster = loadRoster(groupName);
      if (roster.length === 0) {
        const parsed = parseStudents();
        if (parsed.length > 0) saveRoster(groupName, parsed);
      }
    }

    function applyLocalStateToUI(groupName) {
      const state = loadGroupState(groupName);
      Object.entries(state).forEach(([k, status]) => {
        const [student, zone, task] = k.split("|");
        const selectorAll =
          `.status-inner[data-student="${encodeURIComponent(student)}"]` +
          `[data-zone="${zone}"][data-task="${encodeURIComponent(task)}"]`;
        const selectorOne = selectorAll + `[data-status="${status}"]`;
        const cellToSelect = document.querySelector(selectorOne);
        if (!cellToSelect) return;
        document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
        cellToSelect.classList.add("selected");
      });
    }

    function loadQueue() {
      try {
        const raw = localStorage.getItem(LOCAL_QUEUE_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch { return []; }
    }

    function saveQueue(queue) {
      try { localStorage.setItem(LOCAL_QUEUE_KEY, JSON.stringify(queue)); } catch {}
    }

    function enqueueOp(op) {
      let queue = loadQueue();
      queue = queue.filter(q => !(q.group_name === op.group_name && q.student === op.student && q.zone === op.zone && q.task === op.task));
      queue.push(op);
      saveQueue(queue);
    }

    function getQueueCount() {
      const q = loadQueue();
      return Array.isArray(q) ? q.length : 0;
    }

    async function checkCloudReachable(timeoutMs = 2000) {
      try {
        const controller = new AbortController();
        const t = setTimeout(() => controller.abort(), timeoutMs);

        const url = SUPABASE_URL + "/rest/v1/";
        const res = await fetch(url, {
          method: "GET",
          headers: { apikey: SUPABASE_ANON_KEY },
          signal: controller.signal
        });

        clearTimeout(t);
        return !!res;
      } catch {
        return false;
      }
    }

    function updateConnectionIndicator() {
      const queueCount = getQueueCount();

      if (cloudReachable) {
        connectionStatusEl.classList.add("online");
        connectionStatusEl.classList.remove("offline");
        connectionTextEl.textContent = "Online: cloud is reachable.";
        connectionRightEl.textContent = queueCount > 0 ? ("Pending sync: " + queueCount) : "Synced";
      } else {
        connectionStatusEl.classList.add("offline");
        connectionStatusEl.classList.remove("online");
        connectionTextEl.textContent = "Offline: cloud not reachable (saving locally).";
        connectionRightEl.textContent = queueCount > 0 ? ("Queued: " + queueCount) : "Local only";
      }
    }

    async function refreshConnectivity() {
      connectionTextEl.textContent = "Checking cloud connection…";
      connectionRightEl.textContent = "—";
      cloudReachable = await checkCloudReachable(2000);
      updateConnectionIndicator();
    }

    async function trySaveToSupabase(op, isRetry = false) {
      if (!cloudReachable) {
        enqueueOp(op);
        if (!isRetry) setMessage("Saved locally. Cloud not reachable.");
        updateConnectionIndicator();
        return false;
      }

      try {
        const { error: delError } = await supabaseClient
          .from("evaluations")
          .delete()
          .eq("group_name", op.group_name)
          .eq("student", op.student)
          .eq("zone", op.zone)
          .eq("task", op.task);

        if (delError) throw delError;

        const { error: insError } = await supabaseClient.from("evaluations").insert(op);
        if (insError) throw insError;

        if (!isRetry) setMessage("Saved.");
        updateConnectionIndicator();
        return true;
      } catch (e) {
        enqueueOp(op);
        if (!isRetry) {
          const msg = e && e.message ? e.message : String(e);
          setMessage("Saved locally, cloud error: " + msg, true);
        }
        cloudReachable = false;
        updateConnectionIndicator();
        return false;
      }
    }

    async function processQueue() {
      const queue = loadQueue();
      if (queue.length === 0) {
        updateConnectionIndicator();
        return;
      }

      await refreshConnectivity();
      if (!cloudReachable) return;

      const remaining = [];
      setMessage("Syncing offline changes...");
      connectionRightEl.textContent = "Syncing…";

      for (const op of queue) {
        const ok = await trySaveToSupabase(op, true);
        if (!ok) remaining.push(op);
      }

      saveQueue(remaining);

      if (remaining.length === 0) {
        setMessage("Offline changes synced.");
      } else {
        setMessage("Some changes still saved locally. Will retry.", true);
      }
      updateConnectionIndicator();
    }

    function refreshGroupSelectFromLocalOnly() {
      const groups = loadGroupList().slice().sort((a, b) => a.localeCompare(b));
      while (groupSelect.options.length > 1) groupSelect.remove(1);
      groups.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        groupSelect.appendChild(opt);
      });
    }

    // iOS reflow helper (NO scrollLeft changes)
    function forceTableReflow() {
      const prev = tableContainer.style.transform;
      tableContainer.style.transform = "translateZ(0)";
      void tableContainer.offsetHeight;
      tableContainer.style.transform = prev || "";
      requestAnimationFrame(() => { void tableContainer.offsetHeight; });
    }

    function openZoneInfo(zoneNumber) {
      const z = ZONES.find(x => x.zone === zoneNumber);
      if (!z) return;

      const titleText = `${z.title}: ${z.subtitle}`;
      infoTitle.textContent = titleText;

      const parts = [];

      if (z.info) {
        if (z.info.constraintsTitle && Array.isArray(z.info.constraints) && z.info.constraints.length > 0) {
          parts.push(`<div class="modal-section-title">${escapeHtml(z.info.constraintsTitle)}</div>`);
          parts.push("<ul>");
          z.info.constraints.forEach(item => parts.push(`<li>${escapeHtml(item)}</li>`));
          parts.push("</ul>");
        }

        if (z.info.focusTitle && Array.isArray(z.info.focus) && z.info.focus.length > 0) {
          parts.push(`<div class="modal-section-title">${escapeHtml(z.info.focusTitle)}</div>`);
          parts.push("<ul>");
          z.info.focus.forEach(item => parts.push(`<li>${escapeHtml(item)}</li>`));
          parts.push("</ul>");
        }
      }

      if (parts.length === 0) {
        parts.push(`<div class="muted">No additional info for this zone.</div>`);
      }

      infoBody.innerHTML = parts.join("");
      infoBackdrop.classList.add("open");
      infoBackdrop.setAttribute("aria-hidden", "false");
      infoCloseBtn.focus();
    }

    function closeZoneInfo() {
      infoBackdrop.classList.remove("open");
      infoBackdrop.setAttribute("aria-hidden", "true");
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    infoCloseBtn.addEventListener("click", closeZoneInfo);
    infoBackdrop.addEventListener("click", (e) => {
      if (e.target === infoBackdrop) closeZoneInfo();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && infoBackdrop.classList.contains("open")) closeZoneInfo();
    });

    // Table rendering
    function renderTable() {
      const groupName = groupNameInput.value.trim();

      if (!groupName) {
        setMessage("Enter a group name first.", true);
        return;
      }
      if (currentStudents.length === 0) {
        setMessage("Enter at least one student.", true);
        return;
      }

      let html = "<table>";

      // top headers
      html += "<tr><th class='task-col'>Task</th>";
      currentStudents.forEach(student => {
        html += `<th class="student-group-header" colspan="${STATUSES.length}">${escapeHtml(student)}</th>`;
      });
      html += "</tr>";

      html += "<tr><th class='task-col'></th>";
      currentStudents.forEach(() => {
        STATUSES.forEach(status => {
          html += `<th class="status-header" data-status="${status}">${status}</th>`;
        });
      });
      html += "</tr>";

      // zones + tasks
      ZONES.forEach(zoneObj => {
        // zone header row with info button (NOT part of marking grid)
        html += `<tr class="zone-row zone-row-${zoneObj.zone}">`;
        html += `<th class="zone-header task-col">
                  <div class="zone-title-wrap">
                    <div class="zone-title-left">
                      <div class="zone-title">${escapeHtml(zoneObj.title)}</div>
                      <div class="zone-subtitle">${escapeHtml(zoneObj.subtitle)}</div>
                    </div>
                    <div class="info-btn" role="button" tabindex="0" data-zone-info="${zoneObj.zone}" aria-label="Zone ${zoneObj.zone} information">i</div>
                  </div>
                </th>`;
        currentStudents.forEach(student => {
          html += `<th class="zone-header student-group-header" colspan="${STATUSES.length}">${escapeHtml(student)}</th>`;
        });
        html += "</tr>";

        zoneObj.tasks.forEach(taskLabel => {
          html += `<tr><td class="task-col">${escapeHtml(taskLabel)}</td>`;

          currentStudents.forEach(student => {
            STATUSES.forEach(status => {
              html += `
                <td class="status-cell" data-status="${status}">
                  <div class="status-inner"
                       data-student="${encodeURIComponent(student)}"
                       data-zone="${zoneObj.zone}"
                       data-task="${encodeURIComponent(taskLabel)}"
                       data-status="${status}">
                  </div>
                </td>`;
            });
          });

          html += "</tr>";
        });
      });

      html += "</table>";
      tableContainer.innerHTML = html;

      document.querySelectorAll(".status-inner").forEach(el => el.addEventListener("click", onStatusClick));

      // Info buttons
      document.querySelectorAll('[data-zone-info]').forEach(btn => {
        const z = parseInt(btn.getAttribute("data-zone-info"), 10);
        btn.addEventListener("click", () => openZoneInfo(z));
        btn.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            openZoneInfo(z);
          }
        });
      });

      requestAnimationFrame(() => forceTableReflow());
    }

    async function onStatusClick(event) {
      const el = event.currentTarget;
      const student = decodeURIComponent(el.dataset.student);
      const zone = parseInt(el.dataset.zone, 10);
      const taskLabel = decodeURIComponent(el.dataset.task);
      const status = el.dataset.status;
      const groupName = groupNameInput.value.trim();

      const selectorAll =
        `.status-inner[data-student="${encodeURIComponent(student)}"]` +
        `[data-zone="${zone}"][data-task="${encodeURIComponent(taskLabel)}"]`;

      document.querySelectorAll(selectorAll).forEach(node => node.classList.remove("selected"));
      el.classList.add("selected");

      updateLocalState(groupName, student, zone, taskLabel, status);

      const op = { group_name: groupName, student, zone, task: taskLabel, status };
      await trySaveToSupabase(op);
    }

    async function loadSavedMarks() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) return;

      document.querySelectorAll(".status-inner").forEach(node => node.classList.remove("selected"));
      applyLocalStateToUI(groupName);

      await refreshConnectivity();
      if (!cloudReachable) {
        setMessage("Loaded local marks. Cloud not reachable.");
        return;
      }

      await processQueue();

      const { data, error } = await supabaseClient
        .from("evaluations")
        .select("*")
        .eq("group_name", groupName);

      if (error) {
        setMessage("Loaded local marks. Cloud load failed.", true);
        return;
      }

      const localState = loadGroupState(groupName);
      const mergedState = { ...localState };

      (data || []).forEach(row => {
        const key = localKey(row.student, row.zone, row.task);
        if (mergedState[key] == null) mergedState[key] = row.status;
      });

      saveGroupState(groupName, mergedState);

      document.querySelectorAll(".status-inner").forEach(node => node.classList.remove("selected"));
      applyLocalStateToUI(groupName);

      setMessage("Loaded. Local marks kept where present.");
    }

    // CSV export
    function exportCurrentGroupToCSV() {
      const groupName = groupNameInput.value.trim();
      if (!groupName) {
        setMessage("Enter a group name before exporting.", true);
        return;
      }

      const state = loadGroupState(groupName);
      const entries = Object.entries(state);
      if (entries.length === 0) {
        setMessage("No local marks found for this group to export.", true);
        return;
      }

      const headers = ["group_name", "student", "zone", "task", "status"];
      const lines = [headers.join(",")];

      entries.forEach(([key, status]) => {
        const [student, zone, task] = key.split("|");
        const rowObj = { group_name: groupName, student, zone, task, status };

        const values = headers.map(h => {
          let val = rowObj[h];
          if (val == null) val = "";
          val = String(val).replace(/"/g, '""');
          if (val.search(/[",\n]/) !== -1) val = '"' + val + '"';
          return val;
        });

        lines.push(values.join(","));
      });

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const link = document.createElement("a");
      link.href = url;
      link.download = `snowboard_assessment_${groupName.replace(/\s+/g, "_")}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setMessage("CSV exported from local data.");
    }

    document.getElementById("applyLayoutBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();

      if (!groupName) { setMessage("Enter a group name first.", true); return; }
      if (currentStudents.length === 0) { setMessage("Enter at least one student.", true); return; }

      saveRoster(groupName, currentStudents);
      registerGroupName(groupName);
      refreshGroupSelectFromLocalOnly();

      renderTable();
      clearMessage();
      applyLocalStateToUI(groupName);

      refreshConnectivity();
    });

    document.getElementById("loadBtn").addEventListener("click", () => {
      const groupName = groupNameInput.value.trim();
      currentStudents = parseStudents();
      if (groupName && currentStudents.length > 0) {
        saveRoster(groupName, currentStudents);
        registerGroupName(groupName);
        refreshGroupSelectFromLocalOnly();
      }
      renderTable();
      loadSavedMarks();
    });

    exportBtn.addEventListener("click", exportCurrentGroupToCSV);

    useGroupBtn.addEventListener("click", () => {
      const selectedGroup = groupSelect.value;
      if (!selectedGroup) {
        setMessage("Select a saved group first.", true);
        return;
      }

      groupNameInput.value = selectedGroup;

      const roster = loadRoster(selectedGroup);
      if (roster.length > 0) {
        studentsInput.value = roster.join(", ");
      }

      currentStudents = parseStudents();
      renderTable();
      loadSavedMarks();

      refreshConnectivity();
    });

    window.addEventListener("pageshow", () => {
      refreshGroupSelectFromLocalOnly();
      refreshConnectivity();
      requestAnimationFrame(() => forceTableReflow());
    });

    window.addEventListener("orientationchange", () => requestAnimationFrame(() => forceTableReflow()));
    window.addEventListener("resize", () => requestAnimationFrame(() => forceTableReflow()));

    // Initial layout
    refreshGroupSelectFromLocalOnly();
    currentStudents = parseStudents();
    renderTable();
    refreshConnectivity();
  </script>
</body>
</html>