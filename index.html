<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Snowboard Assessment</title>

    <!-- Supabase JS (v2) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
  :root {
    --border: #111;
    --bg: #f4f6f8;

    --incBg: #f8e6e8; /* light red */
    --conBg: #f7f2dc; /* light yellow */
    --refBg: #e5f3e6; /* light green */

    --btnGreen: #2f6b2f;
    --btnDark: #4b4f55;

    /* Layout sizing */
    --taskColW: clamp(160px, 34vw, 280px);
    --cellW: 54px;
    --studentHeaderW: calc(var(--cellW) * 3);

    /* Sticky header offsets (match header row heights) */
    --theadRow1H: 56px;
    --theadRow2H: 48px;
  }

  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg);
    margin: 16px;
    color: #111;
  }

  h1 {
    margin: 0 0 6px;
    font-size: 44px;
    letter-spacing: -0.5px;
  }

  .sub {
    margin: 0 0 14px;
    color: #333;
    font-size: 16px;
  }

  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr auto auto auto;
    gap: 10px 14px;
    align-items: center;
    max-width: 1200px;
  }

  .controls label {
    display: grid;
    gap: 6px;
    font-weight: 700;
  }

  input[type="text"] {
    padding: 10px 12px;
    border-radius: 8px;
    border: 2px solid #c9d1d9;
    background: #fff;
    font-size: 16px;
  }

  select {
    padding: 10px 12px;
    border-radius: 8px;
    border: 2px solid #c9d1d9;
    background: #fff;
    font-size: 16px;
    width: 100%;
  }

  .btn {
    border: none;
    border-radius: 10px;
    padding: 12px 16px;
    font-size: 18px;
    font-weight: 800;
    color: #fff;
    cursor: pointer;
    white-space: nowrap;
  }

  .btn.green { background: var(--btnGreen); }
  .btn.dark { background: var(--btnDark); }

  .row2 {
    display: grid;
    grid-template-columns: 1fr auto auto;
    gap: 10px 14px;
    align-items: end;
    max-width: 1200px;
    margin-top: 10px;
  }

  .status {
    margin-top: 12px;
    border: 2px solid #c9d1d9;
    border-radius: 10px;
    padding: 12px 14px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #fff;
  }

  .statusLeft {
    display: flex;
    gap: 10px;
    align-items: center;
    font-weight: 800;
    font-size: 20px;
  }

  .dot {
    width: 18px;
    height: 18px;
    border-radius: 999px;
    background: #999;
  }

  .dot.online { background: #2ea043; }
  .dot.offline { background: #d1242f; }

  .statusRight {
    font-weight: 900;
    font-size: 22px;
    color: #b45309;
  }

  .statusRight.ok { color: #2f6b2f; }
  .statusRight.bad { color: #b91c1c; }

  hr.rule {
    border: none;
    border-top: 6px solid #111;
    margin: 14px 0;
  }

  /* Scroll wrapper: THIS is what scrolls horizontally */
  .gridWrap {
    width: 100%;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    border-top: 4px solid #111;
    padding-top: 0;
  }

  /* Table: Safari sticky is most reliable with separate borders */
  table.grid {
    border-collapse: separate;
    border-spacing: 0;
    background: #fff;
    width: max-content;     /* allow full width, do not squeeze */
    min-width: 100%;
    table-layout: fixed;    /* keep cell widths stable */
  }

  th, td {
    border: 4px solid var(--border);
    padding: 10px 10px;
    vertical-align: middle;
    background-clip: padding-box;
  }

  th {
    background: #efefef;
    font-weight: 900;
    text-align: center;
  }

  /* Task column sizing */
  th.taskHead,
  td.taskCell,
  td.zoneCell {
    width: var(--taskColW);
    min-width: var(--taskColW);
    max-width: var(--taskColW);
    text-align: left;
  }

  td.taskCell {
    font-size: 22px;
    line-height: 1.15;
  }

  /* Student header group cell (spans 3) */
  th.studentHead {
    min-width: var(--studentHeaderW);
    width: var(--studentHeaderW);
    font-size: 28px;
  }

  th.subHead {
    font-size: 20px;
    padding: 8px 0;
    min-width: var(--cellW);
    width: var(--cellW);
  }

  td.markCell {
    min-width: var(--cellW);
    width: var(--cellW);
    padding: 10px 6px;
    text-align: center;
  }

  /* Backgrounds by status column */
  .bgInc { background: var(--incBg); }
  .bgCon { background: var(--conBg); }
  .bgRefi { background: var(--refBg); }

  /* Clickable square */
  .box {
    width: 46px;
    height: 46px;
    border-radius: 10px;
    border: 3px solid #9aa4af;
    background: #e9edf1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    font-weight: 1000;
    color: #111;
    user-select: none;
    cursor: pointer;
  }

  /* Checked fill matches its column */
  .checked .box { color: #111; }
  .checked.bgInc .box { background: #e56a72; border-color: #b34149; }
  .checked.bgCon .box { background: #e3c251; border-color: #b6952b; }
  .checked.bgRefi .box { background: #5fb06a; border-color: #3f7e48; }

  /* Zone rows */
  td.zoneCell {
    background: #dbeaf7;
    font-weight: 1000;
    font-size: 40px;
    letter-spacing: -0.5px;
  }

  .zoneSub {
    display: block;
    margin-top: 6px;
    font-size: 24px;
    font-weight: 900;
    opacity: 0.75;
  }

  /* Info button (lowercase i) */
  .infoBtn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 34px;
    height: 34px;
    border-radius: 999px;
    border: 3px solid #111;
    background: #fff;
    font-weight: 900;
    font-size: 20px;
    line-height: 1;
    margin-left: 10px;
    cursor: pointer;
    user-select: none;
  }

  /* Modal */
  .modalOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    display: none;
    align-items: center;
    justify-content: center;
    padding: 16px;
    z-index: 9999;
  }

  .modal {
    width: min(820px, 96vw);
    background: #fff;
    border-radius: 14px;
    border: 2px solid #c9d1d9;
    overflow: hidden;
  }

  .modalHead {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 16px;
    background: #f3f4f6;
    border-bottom: 2px solid #c9d1d9;
    font-weight: 900;
    font-size: 18px;
  }

  .modalBody {
    padding: 16px;
    font-size: 16px;
    line-height: 1.45;
    white-space: pre-wrap;
  }

  .modalClose {
    background: #111;
    color: #fff;
    border: none;
    border-radius: 10px;
    padding: 10px 12px;
    cursor: pointer;
    font-weight: 900;
  }

  .hint {
    margin-top: 8px;
    color: #b91c1c;
    font-weight: 800;
  }

  /* ===========================
     STICKY (iPhone Safari safe)
     =========================== */

  /* Sticky header row 1 */
  table.grid thead tr:first-child th {
    position: sticky;
    top: 0;
    z-index: 70;
    background: #efefef;
  }

  /* Sticky header row 2 */
  table.grid thead tr:nth-child(2) th {
    position: sticky;
    top: var(--theadRow1H);
    z-index: 65;
    background: #efefef;
  }

  /* Sticky task column header cell */
  table.grid thead th.taskHead {
    position: sticky;
    left: 0;
    z-index: 90; /* highest */
    background: #efefef;
  }

  /* Sticky task column body cells */
  table.grid tbody td.taskCell,
  table.grid tbody td.zoneCell {
    position: sticky;
    left: 0;
    z-index: 40;
    background: #fff;
  }

  /* Zone cell keeps its own background on top */
  table.grid tbody td.zoneCell {
    z-index: 50;
    background: #dbeaf7;
  }

  /* Crisp divider on sticky column edge */
  table.grid th.taskHead,
  table.grid td.taskCell,
  table.grid td.zoneCell {
    box-shadow: 4px 0 0 var(--border);
  }

  /* Mobile adjustments */
  @media (max-width: 760px) {
    h1 { font-size: 38px; }

    .controls { grid-template-columns: 1fr; }
    .row2 { grid-template-columns: 1fr; }

    .btn {
      width: 100%;
      justify-self: start;
    }

    :root {
      --taskColW: clamp(150px, 42vw, 240px);
      --cellW: 52px;
      --theadRow1H: 54px;
      --theadRow2H: 46px;
    }

    th.studentHead { font-size: 24px; }
  }
</style>
  </head>

  <body>
    <h1>Snowboard Assessment</h1>
    <p class="sub">
      Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved
      locally first and synced to Supabase automatically when possible.
    </p>

    <div class="controls">
      <label>
        Group name:
        <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />
      </label>

      <label>
        Students:
        <input
          id="studentsInput"
          type="text"
          placeholder="Example: 1 Albert, 2 Benedict, 3 Reuben"
        />
      </label>

      <button id="applyLayoutBtn" class="btn green">Apply layout</button>
      <button id="exportBtn" class="btn dark">Export CSV (this group)</button>
      <button id="loadLocalBtn" class="btn green">Load saved marks</button>
    </div>

    <div class="row2">
      <label>
        Saved groups:
        <select id="savedGroupsSelect">
          <option value="">Select a saved group</option>
        </select>
      </label>

      <button id="useGroupBtn" class="btn dark">Use group</button>
      <button id="pullCloudBtn" class="btn dark">Pull from cloud</button>
    </div>

    <div class="status" id="statusBar">
      <div class="statusLeft">
        <div class="dot" id="statusDot"></div>
        <div id="statusText">Checking cloud...</div>
      </div>
      <div class="statusRight" id="syncText">Saved locally</div>
    </div>

    <div class="hint" id="hintText" style="display: none"></div>

    <hr class="rule" />

    <div class="gridWrap">
      <table class="grid" id="gridTable"></table>
    </div>

    <!-- Info Modal -->
    <div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
      <div class="modal">
        <div class="modalHead">
          <div id="modalTitle">Info</div>
          <button id="modalClose" class="modalClose">Close</button>
        </div>
        <div id="modalBody" class="modalBody"></div>
      </div>
    </div>

    <script>
      /********************
       * Supabase config
       ********************/
      const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
      const SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";
      const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      // Tables / columns
      const COURSES_TABLE = "courses";
      const EVALS_TABLE = "evaluations";

      const COURSE_GROUP_COL = "group_name";
      const COURSE_CLOSED_COL = "is_closed";
      const COURSE_PARTICIPANT_MAP_COL = "participant_map"; // confirmed lowercase

      // If your evaluations column is NOT named "mark", change this:
      const EVAL_MARK_COL = "status";

      // Unique constraint is: (group_name, student, zone, task)
      const EVAL_ON_CONFLICT = "group_name,student,zone,task";

      /********************
       * Zones definition
       ********************/
      const ZONES = [
        {
          zone: 1,
          title: "FLATS AND MAGIC CARPET AREA",
          tasks: [
            "Skating in a Straight Line",
            "Skating Around Cones",
            "Skating Across a Slope (Both Edges)",
            "Switch Skating",
            "J-Turns (One-Footed)",
          ],
          infoTitle: "Zone 1 Info",
          infoBody:
            "Possible Constraints\n" +
            "• Glide with reduced space or toward a target marker.\n" +
            "• Perform skating tasks with a variable snow surface (slightly packed or soft).\n" +
            "• Skating around obstacles (example: cones, stubbies)\n" +
            "• Use minor slope gradient to encourage longer glide or speed awareness.\n\n" +
            "Evaluation Focus\n" +
            "• Balance and coordination while gliding\n" +
            "• Smooth push and glide transitions\n" +
            "• Controlled direction and stopping\n" +
            "• Awareness of surrounding space and other riders",
        },
        {
          zone: 2,
          title: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
          tasks: [
            "Riding the Lift (magic carpet, t-bar, or chair)",
            "Standing on Both Edges",
            "Side Slipping (Both Edges)",
            "Traversing (Both Edges)",
            "Linked Turns",
          ],
          infoTitle: "Zone 2 Info",
          infoBody:
            "Possible variations\n" +
            "• Perform a controlled stop during a sideslip or traverse.\n" +
            "• Link multiple turns with slight changes in snow texture or slope pitch.\n" +
            "• Ride both toe and heel sides in the same run.\n" +
            "• Follow a marked path or cone line to encourage directional awareness.\n\n" +
            "Evaluation Focus\n" +
            "• Smooth loading and unloading of the magic carpet\n" +
            "• Balanced posture while standing on both edges\n" +
            "• Controlled side slips without abrupt stops\n" +
            "• Stable traverses across the slope\n" +
            "• Linked turns showing direction and speed control",
        },
        {
          zone: 3,
          title: "FLAGGED GREEN RUN",
          tasks: [
            "Linked Turns (Continuous)",
            "Speed Control Through Turn Shape",
            "Edge Release and Engagement",
            "Flow and Continuity",
            "Adaptability",
          ],
          infoTitle: "Zone 3 Info",
          infoBody:
            "Evaluation Focus\n" +
            "• Continuous linked turns along the flagged path\n" +
            "• Speed managed through turn shape, not braking\n" +
            "• Controlled edge release and engagement\n" +
            "• Flow maintained through variable turn timing\n" +
            "• Adaptability to terrain, snow, and surrounding traffic",
        },
      ];

      /********************
       * State
       ********************/
      const LS_PREFIX = "sb_assess_v3:";
      const LS_GROUP_LIST = LS_PREFIX + "groups_local";
      const LS_MARKS_PREFIX = LS_PREFIX + "marks:";
      const LS_LAST_USED = LS_PREFIX + "last_used_group";

      let currentGroup = "";
      let participants = []; // array of { label, bib, name }
      let marks = {}; // key: zone|task|studentLabel => "Inc"|"Con"|"Refi"|"" (one chosen)

      /********************
       * Elements
       ********************/
      const elGroupName = document.getElementById("groupName");
      const elStudents = document.getElementById("studentsInput");
      const elApply = document.getElementById("applyLayoutBtn");
      const elExport = document.getElementById("exportBtn");
      const elLoadLocal = document.getElementById("loadLocalBtn");
      const elSavedGroups = document.getElementById("savedGroupsSelect");
      const elUseGroup = document.getElementById("useGroupBtn");
      const elPullCloud = document.getElementById("pullCloudBtn");

      const elGrid = document.getElementById("gridTable");

      const elStatusDot = document.getElementById("statusDot");
      const elStatusText = document.getElementById("statusText");
      const elSyncText = document.getElementById("syncText");
      const elHint = document.getElementById("hintText");

      const elModalOverlay = document.getElementById("modalOverlay");
      const elModalTitle = document.getElementById("modalTitle");
      const elModalBody = document.getElementById("modalBody");
      const elModalClose = document.getElementById("modalClose");

      /********************
       * Helpers
       ********************/
      function setHint(msg) {
        if (!msg) {
          elHint.style.display = "none";
          elHint.textContent = "";
          return;
        }
        elHint.style.display = "block";
        elHint.textContent = msg;
      }

      function setCloudStatus({ online, message, syncState }) {
        elStatusDot.classList.remove("online", "offline");
        elSyncText.classList.remove("ok", "bad");

        if (online) {
          elStatusDot.classList.add("online");
          elStatusText.textContent = message || "Online: cloud is reachable.";
        } else {
          elStatusDot.classList.add("offline");
          elStatusText.textContent = message || "Offline: using local storage.";
        }

        if (syncState === "ok") {
          elSyncText.textContent = "Synced";
          elSyncText.classList.add("ok");
        } else if (syncState === "bad") {
          elSyncText.textContent = "Sync error";
          elSyncText.classList.add("bad");
        } else {
          elSyncText.textContent = "Saved locally";
        }
      }

      function marksKey(zone, task, studentLabel) {
        return `${zone}|${task}|${studentLabel}`;
      }

      function saveMarksLocal() {
        if (!currentGroup) return;
        localStorage.setItem(LS_MARKS_PREFIX + currentGroup, JSON.stringify(marks));
        localStorage.setItem(LS_LAST_USED, currentGroup);
        // keep local group list
        const list = new Set(JSON.parse(localStorage.getItem(LS_GROUP_LIST) || "[]"));
        list.add(currentGroup);
        localStorage.setItem(LS_GROUP_LIST, JSON.stringify([...list].sort()));
      }

      function loadMarksLocal(groupName) {
        const raw = localStorage.getItem(LS_MARKS_PREFIX + groupName);
        marks = raw ? JSON.parse(raw) : {};
      }

      function openModal(title, body) {
        elModalTitle.textContent = title || "Info";
        elModalBody.textContent = body || "";
        elModalOverlay.style.display = "flex";
      }
      function closeModal() {
        elModalOverlay.style.display = "none";
      }

      elModalClose.addEventListener("click", closeModal);
      elModalOverlay.addEventListener("click", (e) => {
        if (e.target === elModalOverlay) closeModal();
      });

      function parseParticipants(input) {
        // accepts "1 Albert, 6 Benedict" or "Albert, Benedict"
        const parts = input
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);

        const parsed = parts.map((p) => {
          const m = p.match(/^(\d+)\s+(.*)$/);
          if (m) {
            const bib = Number(m[1]);
            const name = m[2].trim();
            return { bib, name, label: `${bib} ${name}` };
          }
          return { bib: null, name: p, label: p };
        });

        // sorting rule:
        // - if all have bib numbers: sort by bib asc
        // - else: sort by label alpha
        const allHaveBib = parsed.length > 0 && parsed.every((x) => typeof x.bib === "number");
        parsed.sort((a, b) => {
          if (allHaveBib) return a.bib - b.bib;
          return a.label.localeCompare(b.label);
        });

        return parsed;
      }

      function buildParticipantMap(participantsArr) {
        // store bib->name when bib exists, else store name->name
        const map = {};
        for (const p of participantsArr) {
          if (typeof p.bib === "number") map[String(p.bib)] = p.name;
          else map[p.name] = p.name;
        }
        return map;
      }

      /********************
       * Cloud check + group list
       ********************/
      async function checkCloudReachable() {
        try {
          // tiny query; if key is bad, you'll get an error here
          const { error } = await supabaseClient.from(COURSES_TABLE).select("group_name").limit(1);
          if (error) throw error;
          setCloudStatus({ online: true, message: "Online: cloud is reachable.", syncState: "" });
          return true;
        } catch (e) {
          setCloudStatus({ online: false, message: "Offline: using local storage.", syncState: "" });
          return false;
        }
      }

      async function refreshCloudGroupsDropdown() {
        const online = await checkCloudReachable();
        if (!online) return;

        const { data, error } = await supabaseClient
          .from(COURSES_TABLE)
          .select("group_name,is_closed")
          .eq(COURSE_CLOSED_COL, false)
          .order("group_name", { ascending: true });

        if (error) {
          setCloudStatus({ online: true, message: "Online, but cannot read cloud groups.", syncState: "bad" });
          return;
        }

        // Populate dropdown
        const current = elSavedGroups.value;
        elSavedGroups.innerHTML = `<option value="">Select a saved group</option>`;
        for (const row of data || []) {
          const opt = document.createElement("option");
          opt.value = row.group_name;
          opt.textContent = row.group_name;
          elSavedGroups.appendChild(opt);
        }
        if (current) elSavedGroups.value = current;
      }

      /********************
       * Cloud: upsert course row
       ********************/
      async function upsertCourseRow(groupName, participantsArr) {
        const participant_map = buildParticipantMap(participantsArr);

        const payload = {
          [COURSE_GROUP_COL]: groupName,
          [COURSE_CLOSED_COL]: false,
          [COURSE_PARTICIPANT_MAP_COL]: participant_map,
        };

        const { error } = await supabaseClient
          .from(COURSES_TABLE)
          .upsert(payload, { onConflict: COURSE_GROUP_COL });

        if (error) throw error;
      }

      /********************
       * Cloud: upsert evaluation mark
       ********************/
      async function upsertEvaluationMark({ group_name, student, zone, task, mark }) {
  const payload = {
    group_name,
    student,
    zone,
    task,
    [EVAL_MARK_COL]: mark,
  };

  const { error } = await supabaseClient
    .from(EVALS_TABLE)
    .upsert(payload, { onConflict: EVAL_ON_CONFLICT });

  if (error) throw error;
}

      /********************
       * Pull group from cloud
       ********************/
      async function pullGroupFromCloud(groupName) {
        setHint("");
        const online = await checkCloudReachable();
        if (!online) {
          setHint("Cloud is not reachable. Try again when online.");
          return;
        }
        if (!groupName) {
          setHint("Enter or select the group name to pull from the cloud.");
          return;
        }

        // Load course (participants)
        const { data: courseRows, error: courseErr } = await supabaseClient
          .from(COURSES_TABLE)
          .select("group_name,is_closed,participant_map")
          .eq("group_name", groupName)
          .limit(1);

        if (courseErr || !courseRows || courseRows.length === 0) {
          setHint("Group not found in cloud.");
          return;
        }

        const course = courseRows[0];
        if (course.is_closed) {
          setHint("That group is closed in the cloud.");
          return;
        }

        currentGroup = course.group_name;
        elGroupName.value = currentGroup;

        // Convert participant_map into sorted participants
        const pm = course.participant_map || {};
        const entries = Object.entries(pm);

        const allNumericKeys = entries.length > 0 && entries.every(([k]) => /^\d+$/.test(k));
        let derived = entries.map(([k, v]) => {
          if (allNumericKeys) {
            const bib = Number(k);
            const name = String(v || "").trim();
            return { bib, name, label: `${bib} ${name}` };
          }
          // name-only
          const name = String(k).trim();
          return { bib: null, name, label: name };
        });

        derived.sort((a, b) => {
          if (allNumericKeys) return a.bib - b.bib;
          return a.label.localeCompare(b.label);
        });

        participants = derived;

        // Load marks from cloud
        const { data: evalRows, error: evalErr } = await supabaseClient
          .from(EVALS_TABLE)
          .select("group_name,student,zone,task," + EVAL_MARK_COL)
          .eq("group_name", currentGroup);

        if (evalErr) {
          setHint("Loaded group, but could not load marks from cloud.");
          marks = {};
        } else {
          marks = {};
          for (const r of evalRows || []) {
            const key = marksKey(r.zone, r.task, r.student);
            marks[key] = r[EVAL_MARK_COL] || "";
          }
        }

        // Save locally and render
        saveMarksLocal();
        renderGrid();
        setHint("Pulled from cloud and saved locally.");
        setCloudStatus({ online: true, message: "Online: cloud is reachable.", syncState: "ok" });
      }

      /********************
       * Render grid
       ********************/
      function renderGrid() {
        elGrid.innerHTML = "";

        // Header row 1
        const tr1 = document.createElement("tr");
        const thTask = document.createElement("th");
        thTask.className = "taskHead";
        thTask.textContent = "Task";
        tr1.appendChild(thTask);

        for (const p of participants) {
          const th = document.createElement("th");
          th.className = "studentHead";
          th.colSpan = 3;
          th.textContent = p.label;
          tr1.appendChild(th);
        }
        elGrid.appendChild(tr1);

        // Header row 2: Inc/Con/Refi
        const tr2 = document.createElement("tr");
        const thBlank = document.createElement("th");
        thBlank.className = "taskHead";
        thBlank.textContent = "";
        tr2.appendChild(thBlank);

        for (let i = 0; i < participants.length; i++) {
          const thInc = document.createElement("th");
          thInc.className = "subHead bgInc";
          thInc.textContent = "Inc";
          tr2.appendChild(thInc);

          const thCon = document.createElement("th");
          thCon.className = "subHead bgCon";
          thCon.textContent = "Con";
          tr2.appendChild(thCon);

          const thRef = document.createElement("th");
          thRef.className = "subHead bgRefi";
          thRef.textContent = "Refi";
          tr2.appendChild(thRef);
        }
        elGrid.appendChild(tr2);

        // Zones and tasks
        for (const z of ZONES) {
          // Zone header row
          const zr = document.createElement("tr");

          const zc = document.createElement("td");
          zc.className = "zoneCell";
          zc.innerHTML = `Zone ${z.zone}<span class="zoneSub">${z.title}</span>`;

          // info button
          const infoBtn = document.createElement("span");
          infoBtn.className = "infoBtn";
          infoBtn.textContent = "i";
          infoBtn.title = "Information";
          infoBtn.addEventListener("click", () => openModal(z.infoTitle, z.infoBody));
          zc.appendChild(infoBtn);

          zr.appendChild(zc);

          for (const p of participants) {
            const tdSpan = document.createElement("td");
            tdSpan.colSpan = 3;
            tdSpan.style.textAlign = "center";
            tdSpan.style.fontWeight = "1000";
            tdSpan.style.fontSize = "28px";
            tdSpan.textContent = p.label;
            zr.appendChild(tdSpan);
          }
          elGrid.appendChild(zr);

          // Task rows
          for (const task of z.tasks) {
            const tr = document.createElement("tr");

            const tdTask = document.createElement("td");
            tdTask.className = "taskCell";
            tdTask.textContent = task;
            tr.appendChild(tdTask);

            for (const p of participants) {
              tr.appendChild(makeMarkCell(z.zone, task, p.label, "Inc"));
              tr.appendChild(makeMarkCell(z.zone, task, p.label, "Con"));
              tr.appendChild(makeMarkCell(z.zone, task, p.label, "Refi"));
            }

            elGrid.appendChild(tr);
          }
        }
      }

      function makeMarkCell(zone, task, studentLabel, colMark) {
        const td = document.createElement("td");
        td.className = "markCell " + (colMark === "Inc" ? "bgInc" : colMark === "Con" ? "bgCon" : "bgRefi");

        const box = document.createElement("div");
        box.className = "box";
        box.textContent = ""; // tick handled by state

        const key = marksKey(zone, task, studentLabel);
        const current = marks[key] || "";

        if (current === colMark) {
          td.classList.add("checked");
          box.textContent = "✓";
        }

        td.addEventListener("click", async () => {
          if (!currentGroup) {
            setHint("Enter a group name and click Apply layout first.");
            return;
          }

          // toggle: if clicking same mark, clear; else set to that mark
          const existing = marks[key] || "";
          const next = existing === colMark ? "" : colMark;

          marks[key] = next;
          saveMarksLocal();
          renderGrid();

          // try cloud write
          const online = await checkCloudReachable();
          if (!online) {
            setCloudStatus({ online: false, message: "Offline: using local storage.", syncState: "" });
            return;
          }

          try {
            // Write the course row too, so new groups exist in cloud and appear in dropdown
            await upsertCourseRow(currentGroup, participants);

            // If cleared, store empty mark (keeps one row per student/task).
            // If you prefer DELETE on clear, tell me and I will switch it.
            await upsertEvaluationMark({
              group_name: currentGroup,
              student: studentLabel,
              zone,
              task,
              mark: next,
            });

            setCloudStatus({ online: true, message: "Online: cloud is reachable.", syncState: "ok" });
            // refresh cloud groups list in case group is new
            refreshCloudGroupsDropdown();
          } catch (e) {
  setCloudStatus({ online: true, message: "Online, but sync failed.", syncState: "bad" });
  const msg =
    (e && e.message) ? e.message :
    (typeof e === "string") ? e :
    JSON.stringify(e);
  setHint("Sync failed: " + msg);
}
        });

        td.appendChild(box);
        return td;
      }

      /********************
       * CSV export
       ********************/
      function exportCSV() {
        if (!currentGroup || participants.length === 0) {
          setHint("No group loaded.");
          return;
        }

        const header = ["Zone", "Task", ...participants.flatMap((p) => [p.label + " Inc", p.label + " Con", p.label + " Refi"])];
        const rows = [header];

        for (const z of ZONES) {
          for (const task of z.tasks) {
            const row = [String(z.zone), task];
            for (const p of participants) {
              const key = marksKey(z.zone, task, p.label);
              const m = marks[key] || "";
              row.push(m === "Inc" ? "✓" : "");
              row.push(m === "Con" ? "✓" : "");
              row.push(m === "Refi" ? "✓" : "");
            }
            rows.push(row);
          }
        }

        const csv = rows
          .map((r) =>
            r
              .map((v) => {
                const s = String(v ?? "");
                return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
              })
              .join(",")
          )
          .join("\n");

        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${currentGroup || "assessment"}.csv`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      /********************
       * UI actions
       ********************/
      elApply.addEventListener("click", async () => {
        setHint("");

        const g = elGroupName.value.trim();
        const s = elStudents.value.trim();

        if (!g) return setHint("Enter a group name.");
        if (!s) return setHint("Enter students separated by commas.");

        currentGroup = g;
        participants = parseParticipants(s);

        // save participant list locally
        localStorage.setItem(LS_PREFIX + "participants:" + currentGroup, JSON.stringify(participants));
        localStorage.setItem(LS_LAST_USED, currentGroup);

        // ensure cloud group exists (optional but recommended)
        const online = await checkCloudReachable();
        if (online) {
          try {
            await upsertCourseRow(currentGroup, participants);
            setCloudStatus({ online: true, message: "Online: cloud is reachable.", syncState: "ok" });
            refreshCloudGroupsDropdown();
          } catch (e) {
            setCloudStatus({ online: true, message: "Online, but could not save group to cloud.", syncState: "bad" });
          }
        }

        // load existing local marks if any
        loadMarksLocal(currentGroup);
        renderGrid();
        saveMarksLocal();
      });

      elExport.addEventListener("click", exportCSV);

      elLoadLocal.addEventListener("click", () => {
        setHint("");
        const g = elGroupName.value.trim();
        if (!g) return setHint("Enter a group name first.");

        currentGroup = g;

        const pRaw = localStorage.getItem(LS_PREFIX + "participants:" + currentGroup);
        participants = pRaw ? JSON.parse(pRaw) : [];

        loadMarksLocal(currentGroup);
        renderGrid();
        setHint("Loaded saved marks from this device.");
      });

      elUseGroup.addEventListener("click", () => {
        setHint("");
        const selected = elSavedGroups.value;
        if (!selected) return setHint("Select a group first.");

        currentGroup = selected;
        elGroupName.value = currentGroup;

        const pRaw = localStorage.getItem(LS_PREFIX + "participants:" + currentGroup);
        participants = pRaw ? JSON.parse(pRaw) : [];

        loadMarksLocal(currentGroup);
        renderGrid();
        setHint("Loaded group from local storage on this device.");
      });

      elPullCloud.addEventListener("click", async () => {
        const selected = elSavedGroups.value;
        const typed = elGroupName.value.trim();
        await pullGroupFromCloud(selected || typed);
      });

      /********************
       * Init
       ********************/
      (async function init() {
        // initial statuses
        setCloudStatus({ online: false, message: "Checking cloud...", syncState: "" });

        // populate cloud groups
        await refreshCloudGroupsDropdown();

        // restore last used group locally (if any)
        const last = localStorage.getItem(LS_LAST_USED);
        if (last) {
          elGroupName.value = last;
          currentGroup = last;

          const pRaw = localStorage.getItem(LS_PREFIX + "participants:" + currentGroup);
          participants = pRaw ? JSON.parse(pRaw) : [];

          loadMarksLocal(currentGroup);
          if (participants.length > 0) renderGrid();
        }
      })();
    </script>
  </body>
</html>