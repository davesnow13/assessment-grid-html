<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snowboard Assessment Grid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg: #f4f6f8;
      --border: #111;
      --header-bg: #e0e0e0;

      --inc-bg: #ffebee;
      --con-bg: #fffde7;
      --refi-bg: #e8f5e9;

      --zone1-bg: #e3f2fd;
      --zone2-bg: #e8f5e9;
      --zone3-bg: #fff3e0;

      --ok: #1b5e20;
      --bad: #b00020;
      --muted: #555;

      /* Task column width tuned for portrait */
      --task-col-w: clamp(180px, 34vw, 260px);

      --cell-w: 56px;
      --cell-h: 46px;

      --header-row-h: 44px;
      --subheader-row-h: 38px;
    }

    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: var(--bg);
      color: #111;
    }

    h1{ margin: 0 0 4px 0; }

    .small{
      font-size: 0.95rem;
      color: var(--muted);
      margin: 0 0 12px 0;
      line-height: 1.25;
    }

    .controls{
      margin: 12px 0 12px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    label{ font-size: 0.95rem; }

    input[type="text"], select{
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #c9d1d9;
      font-size: 1rem;
      background: #fff;
      min-width: 220px;
    }

    button{
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #0b6b2f;
      background: #0f9d3d;
      color: white;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
    }

    button.secondary{
      background: #5b636a;
      border-color: #4a5056;
    }

    button:disabled{
      opacity: 0.6;
      cursor: default;
    }

    #statusMsg{
      margin-top: 8px;
      font-size: 0.95rem;
      color: #111;
    }

    #statusMsg.error{ color: var(--bad); }
    #statusMsg.success{ color: var(--ok); }

    .banner{
      margin-top: 10px;
      border-radius: 10px;
      padding: 10px 12px;
      border: 1px solid #c9d1d9;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .banner-left{
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }
    .dot{
      width: 14px; height: 14px;
      border-radius: 50%;
      background: #999;
      border: 1px solid #666;
    }
    .dot.online{ background: #2e7d32; border-color: #1b5e20; }
    .dot.offline{ background: #c62828; border-color: #8e0000; }
    .banner-right{
      font-size: 0.9rem;
      color: var(--muted);
      font-weight: 600;
    }

    #gridWrap{
      margin-top: 12px;
      overflow: auto;
      border: 2px solid var(--border);
      border-radius: 10px;
      background: #fff;
      -webkit-overflow-scrolling: touch;
    }

    table{
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
      table-layout: fixed;
    }

    th, td{
      border: 2px solid var(--border);
      padding: 0;
      vertical-align: middle;
      background-clip: padding-box;
    }

    .task-col{
      width: var(--task-col-w);
      min-width: 180px;
      max-width: 260px;
    }

    .mark-col{
      width: var(--cell-w);
      min-width: var(--cell-w);
      text-align: center;
    }

    thead th{
      position: sticky;
      top: 0;
      background: var(--header-bg);
      z-index: 5;
    }

    thead th.task-col{
      left: 0;
      z-index: 40;
      background: #fff;
      font-weight: 900;
      text-align: left;
      padding-left: 12px;
    }

    tbody td.task-col{
      position: sticky;
      left: 0;
      z-index: 30;
      background: #fff;
      padding: 10px 12px;
      font-size: 1.05rem;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .student-header{
      height: var(--header-row-h);
      font-weight: 900;
      font-size: 1.15rem;
      text-align: center;
      background: var(--header-bg);
      z-index: 5;
    }

    .subheader{
      position: sticky;
      top: var(--header-row-h);
      z-index: 4;
      font-weight: 900;
      font-size: 1.05rem;
      height: var(--subheader-row-h);
      text-align: center;
      background: #fff;
    }

    .sub-inc{ background: var(--inc-bg); }
    .sub-con{ background: var(--con-bg); }
    .sub-refi{ background: var(--refi-bg); }

    .zone-row td.task-col{
      font-weight: 900;
      font-size: 1.25rem;
      padding: 10px 12px;
    }
    .zone-meta{
      display: block;
      font-weight: 700;
      font-size: 0.95rem;
      color: #222;
      margin-top: 2px;
      opacity: 0.85;
    }
    .zone1 td, .zone1 td.task-col{ background: var(--zone1-bg) !important; }
    .zone2 td, .zone2 td.task-col{ background: var(--zone2-bg) !important; }
    .zone3 td, .zone3 td.task-col{ background: var(--zone3-bg) !important; }

    .mark-cell{
      height: var(--cell-h);
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: manipulation;
      user-select: none;
      cursor: pointer;
    }
    .mark-box{
      width: 34px;
      height: 34px;
      border-radius: 6px;
      border: 2px solid #999;
      background: #e9ecef;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      font-weight: 900;
      color: #fff;
    }

    .is-inc .mark-box{ background: #c62828; border-color: #8e0000; }
    .is-con .mark-box{ background: #f9a825; border-color: #c17900; color: #111; }
    .is-refi .mark-box{ background: #2e7d32; border-color: #1b5e20; }

    .col-inc{ background: var(--inc-bg); }
    .col-con{ background: var(--con-bg); }
    .col-refi{ background: var(--refi-bg); }

    .info-btn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 2px solid #222;
      background: #fff;
      color: #111;
      font-weight: 900;
      margin-left: 10px;
      cursor: pointer;
      user-select: none;
    }

    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .modal{
      width: min(720px, 96vw);
      max-height: 86vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      border: 2px solid #111;
      padding: 16px 16px 14px 16px;
    }
    .modal h2{
      margin: 0 0 8px 0;
      font-size: 1.25rem;
    }
    .modal .section-title{
      font-weight: 900;
      margin-top: 12px;
      margin-bottom: 6px;
    }
    .modal ul{
      margin: 6px 0 0 22px;
    }
    .modal .close-row{
      display: flex;
      justify-content: flex-end;
      margin-top: 12px;
    }
    .modal .close-btn{
      background: #5b636a;
      border-color: #4a5056;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 900;
      color: #fff;
      cursor: pointer;
    }

    @media (max-width: 520px){
      :root{
        --task-col-w: clamp(170px, 32vw, 240px);
        --cell-w: 54px;
      }
      input[type="text"], select{ min-width: 170px; }
      .small{ font-size: 0.9rem; }
    }

    @media (orientation: landscape){
      :root{
        --task-col-w: clamp(220px, 24vw, 340px);
      }
    }

    @media print{
      body{ background: #fff; padding: 0; }
      .controls, #statusMsg, .banner{ display: none !important; }
      #gridWrap{ border: none; }
      *{
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to toggle Inc (red), Con (yellow), Refi (green), then blank.
    Data is saved locally first and synced to Supabase automatically when possible.
    You can export to CSV.
  </div>

  <div class="controls">
    <label>
      Group name:
      <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />
    </label>

    <label>
      Students:
      <input id="studentsInput" type="text" placeholder="Reuben, Albert, Benedict" />
    </label>

    <button id="applyBtn">Apply layout</button>
  </div>

  <div class="controls">
    <button id="loadLocalBtn">Load saved marks</button>
    <button id="exportCsvBtn" class="secondary">Export CSV (this group)</button>

    <label style="margin-left: 6px;">
      Saved groups (this device):
      <select id="savedGroupsSelect">
        <option value="">Select a saved group</option>
      </select>
    </label>
    <button id="useGroupBtn" class="secondary">Use saved group</button>
  </div>

  <div class="controls">
    <label>
      Cloud groups (Supabase):
      <select id="cloudGroupsSelect">
        <option value="">Select a cloud group</option>
      </select>
    </label>
    <button id="refreshCloudBtn" class="secondary">Refresh cloud list</button>
    <button id="pullCloudBtn" class="secondary" disabled>Pull from cloud</button>
  </div>

  <div id="statusMsg"></div>

  <div class="banner" id="netBanner">
    <div class="banner-left">
      <span class="dot" id="netDot"></span>
      <span id="netText">Checking connection...</span>
    </div>
    <div class="banner-right" id="syncText">-</div>
  </div>

  <div id="gridWrap"></div>

  <div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true">
    <div class="modal">
      <h2 id="modalTitle">Information</h2>

      <div class="section-title" id="modalSectionA">Possible constraints</div>
      <ul id="modalListA"></ul>

      <div class="section-title" id="modalSectionB">Evaluation focus</div>
      <ul id="modalListB"></ul>

      <div class="close-row">
        <button class="close-btn" id="closeModalBtn">Close</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    /***********************
     * CONFIG
     ***********************/
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY =
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const LS_KEY = "snowboard_assessment_groups_v3";

    const ZONES = [
      {
        id: 1,
        title: "Zone 1",
        subtitle: "FLATS AND MAGIC CARPET AREA",
        cssClass: "zone1",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        info: {
          aTitle: "Possible constraints",
          a: [
            "Glide with reduced space or toward a target marker.",
            "Perform skating tasks with a variable snow surface (slightly packed or soft).",
            "Skating around obstacles (example: cones, stubbies).",
            "Use minor slope gradient to encourage longer glide or speed awareness."
          ],
          bTitle: "Evaluation focus",
          b: [
            "Balance and coordination while gliding",
            "Smooth push and glide transitions",
            "Controlled direction and stopping",
            "Awareness of surrounding space and other riders"
          ]
        }
      },
      {
        id: 2,
        title: "Zone 2",
        subtitle: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        cssClass: "zone2",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        info: {
          aTitle: "Possible variations",
          a: [
            "Perform a controlled stop during a sideslip or traverse.",
            "Link multiple turns with slight changes in snow texture or slope pitch.",
            "Ride both toe and heel sides in the same run.",
            "Follow a marked path or cone line to encourage directional awareness."
          ],
          bTitle: "Evaluation focus",
          b: [
            "Smooth loading and unloading of the magic carpet",
            "Balanced posture while standing on both edges",
            "Controlled side slips without abrupt stops",
            "Stable traverses across the slope",
            "Linked turns showing direction and speed control"
          ]
        }
      },
      {
        id: 3,
        title: "Zone 3",
        subtitle: "FLAGGED GREEN RUN",
        cssClass: "zone3",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        info: {
          aTitle: "Evaluation focus",
          a: [
            "Continuous linked turns along the flagged path",
            "Speed managed through turn shape, not braking",
            "Controlled edge release and engagement",
            "Flow maintained through variable turn timing",
            "Adaptability to terrain, snow, and surrounding traffic"
          ],
          bTitle: "",
          b: []
        }
      }
    ];

    /***********************
     * UI
     ***********************/
    const groupNameEl = document.getElementById("groupName");
    const studentsInputEl = document.getElementById("studentsInput");
    const applyBtn = document.getElementById("applyBtn");
    const loadLocalBtn = document.getElementById("loadLocalBtn");
    const exportCsvBtn = document.getElementById("exportCsvBtn");
    const savedGroupsSelect = document.getElementById("savedGroupsSelect");
    const useGroupBtn = document.getElementById("useGroupBtn");

    const cloudGroupsSelect = document.getElementById("cloudGroupsSelect");
    const refreshCloudBtn = document.getElementById("refreshCloudBtn");
    const pullCloudBtn = document.getElementById("pullCloudBtn");

    const statusMsg = document.getElementById("statusMsg");
    const gridWrap = document.getElementById("gridWrap");

    const netDot = document.getElementById("netDot");
    const netText = document.getElementById("netText");
    const syncText = document.getElementById("syncText");

    const modalBackdrop = document.getElementById("modalBackdrop");
    const closeModalBtn = document.getElementById("closeModalBtn");
    const modalTitle = document.getElementById("modalTitle");
    const modalSectionA = document.getElementById("modalSectionA");
    const modalSectionB = document.getElementById("modalSectionB");
    const modalListA = document.getElementById("modalListA");
    const modalListB = document.getElementById("modalListB");

    /***********************
     * STATE
     ***********************/
    let currentGroup = "";
    let students = [];
    let marks = {};

    let onlineState = false;
    let syncingNow = false;

    let lastScrollLeft = 0;
    let lastScrollTop = 0;

    /***********************
     * UTIL
     ***********************/
    function setMessage(text, isError=false){
      statusMsg.textContent = text;
      statusMsg.className = isError ? "error" : "success";
    }
    function clearMessage(){
      statusMsg.textContent = "";
      statusMsg.className = "";
    }
    function normGroupName(s){ return (s || "").trim(); }
    function parseStudents(s){
      return (s || "")
        .split(",")
        .map(x => x.trim())
        .filter(Boolean);
    }
    function zoneTaskKey(zoneId, task){ return zoneId + "::" + task; }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function captureScroll(){
      lastScrollLeft = gridWrap.scrollLeft;
      lastScrollTop = gridWrap.scrollTop;
    }
    function restoreScroll(){
      gridWrap.scrollLeft = lastScrollLeft;
      gridWrap.scrollTop = lastScrollTop;
    }

    function loadAllLocal(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return {};
        const obj = JSON.parse(raw);
        return (obj && typeof obj === "object") ? obj : {};
      }catch(e){
        console.error(e);
        return {};
      }
    }
    function saveAllLocal(obj){
      localStorage.setItem(LS_KEY, JSON.stringify(obj));
    }
    function upsertLocalGroup(groupName, groupObj){
      const all = loadAllLocal();
      all[groupName] = groupObj;
      saveAllLocal(all);
      refreshSavedGroupsDropdown();
    }
    function getLocalGroup(groupName){
      const all = loadAllLocal();
      return all[groupName] || null;
    }

    function refreshSavedGroupsDropdown(){
      const all = loadAllLocal();
      const names = Object.keys(all).sort((a,b)=>a.localeCompare(b));
      while(savedGroupsSelect.options.length > 1){
        savedGroupsSelect.remove(1);
      }
      names.forEach(n=>{
        const opt = document.createElement("option");
        opt.value = n;
        opt.textContent = n;
        savedGroupsSelect.appendChild(opt);
      });
    }

    function setOnlineBanner(isOnline, extraText){
      onlineState = isOnline;
      if(isOnline){
        netDot.className = "dot online";
        netText.textContent = "Online: cloud is reachable.";
        syncText.textContent = syncingNow ? "Syncing..." : (extraText || "Synced");
      }else{
        netDot.className = "dot offline";
        netText.textContent = "Offline: showing marks stored on this device.";
        syncText.textContent = syncingNow ? "Syncing..." : (extraText || "Local only");
      }
    }

    async function checkCloudReachable(){
      try{
        const { error } = await db.from("courses").select("group_name").limit(1);
        if(error){
          setOnlineBanner(false, "Local only");
          pullCloudBtn.disabled = true;
          return false;
        }
        setOnlineBanner(true, syncingNow ? "Syncing..." : "Synced");
        pullCloudBtn.disabled = !cloudGroupsSelect.value;
        return true;
      }catch(e){
        setOnlineBanner(false, "Local only");
        pullCloudBtn.disabled = true;
        return false;
      }
    }

    /***********************
     * MODAL
     ***********************/
    function openInfoModal(zone){
      modalTitle.textContent = zone.title + ": " + zone.subtitle;

      modalSectionA.textContent = zone.info.aTitle || "";
      modalSectionB.textContent = zone.info.bTitle || "";

      modalListA.innerHTML = "";
      modalListB.innerHTML = "";

      (zone.info.a || []).forEach(x=>{
        const li = document.createElement("li");
        li.textContent = x;
        modalListA.appendChild(li);
      });

      (zone.info.b || []).forEach(x=>{
        const li = document.createElement("li");
        li.textContent = x;
        modalListB.appendChild(li);
      });

      modalSectionA.style.display = zone.info.aTitle ? "block" : "none";
      modalListA.style.display = (zone.info.a && zone.info.a.length) ? "block" : "none";
      modalSectionB.style.display = zone.info.bTitle ? "block" : "none";
      modalListB.style.display = (zone.info.b && zone.info.b.length) ? "block" : "none";

      modalBackdrop.style.display = "flex";
    }
    function closeInfoModal(){
      modalBackdrop.style.display = "none";
    }
    closeModalBtn.addEventListener("click", closeInfoModal);
    modalBackdrop.addEventListener("click", (e)=>{
      if(e.target === modalBackdrop) closeInfoModal();
    });

    /***********************
     * MARKS + GRID
     ***********************/
    function buildEmptyMarks(){
      marks = {};
      ZONES.forEach(z=>{
        z.tasks.forEach(t=>{
          const key = zoneTaskKey(z.id, t);
          marks[key] = {};
          students.forEach(s=>{
            marks[key][s] = "";
          });
        });
      });
    }

    function ensureMarksShape(){
      ZONES.forEach(z=>{
        z.tasks.forEach(t=>{
          const key = zoneTaskKey(z.id, t);
          if(!marks[key]) marks[key] = {};
          students.forEach(s=>{
            if(!(s in marks[key])) marks[key][s] = "";
          });
          Object.keys(marks[key]).forEach(s=>{
            if(!students.includes(s)) delete marks[key][s];
          });
        });
      });
    }

    function renderStatusCell(zoneId, task, student, cellStatus, currentValue){
      const isSelected = (currentValue === cellStatus);
      const cls =
        isSelected
          ? (cellStatus === "Inc" ? "is-inc" : cellStatus === "Con" ? "is-con" : "is-refi")
          : "";

      const bgCls =
        cellStatus === "Inc" ? "col-inc" : cellStatus === "Con" ? "col-con" : "col-refi";

      const check = isSelected ? "âœ“" : "";

      const payload = encodeURIComponent(JSON.stringify({
        z: zoneId,
        t: task,
        s: student,
        set: cellStatus
      }));

      return `
        <td class="mark-col ${bgCls}">
          <div class="mark-cell ${cls}" data-mark="${payload}">
            <div class="mark-box">${check}</div>
          </div>
        </td>
      `;
    }

    function renderGrid(){
      if(!currentGroup || students.length === 0){
        gridWrap.innerHTML = "";
        return;
      }

      ensureMarksShape();
      captureScroll();

      let html = "<table>";

      html += "<thead>";
      html += "<tr>";
      html += `<th class="task-col">Task</th>`;
      students.forEach(st=>{
        html += `<th class="student-header" colspan="3">${escapeHtml(st)}</th>`;
      });
      html += "</tr>";

      html += "<tr>";
      html += `<th class="task-col"></th>`;
      students.forEach(()=>{
        html += `<th class="subheader sub-inc mark-col">Inc</th>`;
        html += `<th class="subheader sub-con mark-col">Con</th>`;
        html += `<th class="subheader sub-refi mark-col">Refi</th>`;
      });
      html += "</tr>";
      html += "</thead>";

      html += "<tbody>";

      ZONES.forEach(zone=>{
        html += `<tr class="zone-row ${zone.cssClass}">`;
        html += `<td class="task-col">
          ${zone.title}
          <span class="zone-meta">${escapeHtml(zone.subtitle)}</span>
          <span class="info-btn" data-zone="${zone.id}" title="Info">i</span>
        </td>`;

        students.forEach(st=>{
          html += `<td class="mark-col" colspan="3" style="font-weight:900;font-size:1.4rem;text-align:center;">
            ${escapeHtml(st)}
          </td>`;
        });
        html += "</tr>";

        zone.tasks.forEach(task=>{
          const key = zoneTaskKey(zone.id, task);

          html += "<tr>";
          html += `<td class="task-col" title="${escapeHtml(task)}">${escapeHtml(task)}</td>`;

          students.forEach(st=>{
            const v = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            html += renderStatusCell(zone.id, task, st, "Inc", v);
            html += renderStatusCell(zone.id, task, st, "Con", v);
            html += renderStatusCell(zone.id, task, st, "Refi", v);
          });

          html += "</tr>";
        });
      });

      html += "</tbody>";
      html += "</table>";

      gridWrap.innerHTML = html;

      gridWrap.querySelectorAll("[data-mark]").forEach(el=>{
        el.addEventListener("click", onMarkClick);
      });

      gridWrap.querySelectorAll(".info-btn").forEach(btn=>{
        btn.addEventListener("click", (e)=>{
          const zid = Number(e.currentTarget.getAttribute("data-zone"));
          const zone = ZONES.find(z=>z.id === zid);
          if(zone) openInfoModal(zone);
        });
      });

      restoreScroll();
    }

    function onMarkClick(e){
      captureScroll();

      const payload = e.currentTarget.getAttribute("data-mark");
      if(!payload) return;

      const obj = JSON.parse(decodeURIComponent(payload));
      const key = zoneTaskKey(obj.z, obj.t);

      if(!marks[key]) marks[key] = {};
      const cur = marks[key][obj.s] || "";

      let next = obj.set;
      if(cur === obj.set) next = "";

      marks[key][obj.s] = next;

      saveCurrentGroupLocal("Local marks saved.");
      scheduleSync();

      renderGrid();
      restoreScroll();
    }

    /***********************
     * LOCAL SAVE/LOAD
     ***********************/
    function getCurrentLocalObject(){
      return {
        group_name: currentGroup,
        students: students.slice(),
        marks: marks,
        updated_at: Date.now()
      };
    }

    function saveCurrentGroupLocal(message){
      if(!currentGroup) return;
      upsertLocalGroup(currentGroup, getCurrentLocalObject());
      if(message) setMessage(message, false);
    }

    function loadGroupFromLocal(groupName){
      const obj = getLocalGroup(groupName);
      if(!obj) return false;

      currentGroup = obj.group_name || groupName;
      students = Array.isArray(obj.students) ? obj.students.slice() : [];
      marks = obj.marks && typeof obj.marks === "object" ? obj.marks : {};

      groupNameEl.value = currentGroup;
      studentsInputEl.value = students.join(", ");

      ensureMarksShape();
      renderGrid();
      setMessage("Loaded from this device.", false);
      return true;
    }

    /***********************
     * CLOUD LIST + PULL
     ***********************/
    function clearCloudDropdown(){
      while(cloudGroupsSelect.options.length > 1){
        cloudGroupsSelect.remove(1);
      }
    }

    async function refreshCloudGroups(){
      clearMessage();
      clearCloudDropdown();
      pullCloudBtn.disabled = true;

      const ok = await checkCloudReachable();
      if(!ok){
        setMessage("Cloud not reachable. You can still use local groups.", true);
        return;
      }

      setMessage("Loading cloud groups...", false);

      try{
        const [{ data: evalData, error: evalErr }, { data: courseData, error: courseErr }] =
          await Promise.all([
            db.from("evaluations").select("group_name"),
            db.from("courses").select("group_name,is_closed")
          ]);

        if(evalErr) console.error(evalErr);
        if(courseErr) console.error(courseErr);

        const closed = new Set();
        if(courseData){
          courseData.forEach(r=>{
            if(r.group_name && r.is_closed) closed.add(r.group_name);
          });
        }

        const set = new Set();

        if(evalData){
          evalData.forEach(r=>{
            if(r.group_name && !closed.has(r.group_name)) set.add(r.group_name);
          });
        }
        if(courseData){
          courseData.forEach(r=>{
            if(r.group_name && !closed.has(r.group_name)) set.add(r.group_name);
          });
        }

        const groups = Array.from(set).sort((a,b)=>a.localeCompare(b));

        groups.forEach(name=>{
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          cloudGroupsSelect.appendChild(opt);
        });

        if(groups.length === 0){
          setMessage("No open cloud groups found.", false);
        }else{
          setMessage("Cloud groups loaded.", false);
        }
      }catch(e){
        console.error(e);
        setMessage("Could not load cloud groups.", true);
      }

      pullCloudBtn.disabled = !cloudGroupsSelect.value;
    }

    async function pullSelectedCloudGroup(){
      clearMessage();

      const ok = await checkCloudReachable();
      if(!ok){
        setMessage("Cloud not reachable. Cannot pull right now.", true);
        return;
      }

      const g = cloudGroupsSelect.value;
      if(!g){
        setMessage("Select a cloud group first.", true);
        return;
      }

      pullCloudBtn.disabled = true;
      setMessage("Pulling from cloud...", false);

      try{
        const { data, error } = await db
          .from("evaluations")
          .select("*")
          .eq("group_name", g);

        if(error){
          console.error(error);
          setMessage("Could not pull evaluations from cloud.", true);
          pullCloudBtn.disabled = false;
          return;
        }

        if(!data || data.length === 0){
          // Still allow you to load group and start marking
          currentGroup = g;
          groupNameEl.value = currentGroup;
          students = parseStudents(studentsInputEl.value);
          if(students.length === 0){
            students = [];
          }
          marks = {};
          buildEmptyMarks();
          saveCurrentGroupLocal("Pulled group (no marks in cloud yet). Saved locally.");
          renderGrid();
          pullCloudBtn.disabled = false;
          return;
        }

        // Build student list from cloud rows
        const sSet = new Set();
        data.forEach(r=>{
          if(r.student) sSet.add(r.student);
        });
        students = Array.from(sSet).sort((a,b)=>a.localeCompare(b));

        currentGroup = g;
        groupNameEl.value = currentGroup;
        studentsInputEl.value = students.join(", ");

        // Build marks from cloud
        marks = {};
        buildEmptyMarks(); // ensures all tasks exist
        data.forEach(r=>{
          const zoneId = Number(r.zone);
          const task = String(r.task || "");
          const student = String(r.student || "");
          const status = String(r.status || "");

          if(!student || !task || !zoneId) return;

          const key = zoneTaskKey(zoneId, task);
          if(!marks[key]) marks[key] = {};
          if(students.includes(student)){
            if(status === "Inc" || status === "Con" || status === "Refi"){
              marks[key][student] = status;
            }
          }
        });

        ensureMarksShape();
        saveCurrentGroupLocal("Pulled from cloud and saved on this device.");
        renderGrid();

        setMessage("Pulled from cloud. You can continue marking on this device.", false);
      }catch(e){
        console.error(e);
        setMessage("Pull failed. Check your Supabase policies and connection.", true);
      }finally{
        pullCloudBtn.disabled = !cloudGroupsSelect.value;
      }
    }

    cloudGroupsSelect.addEventListener("change", ()=>{
      pullCloudBtn.disabled = !cloudGroupsSelect.value || !onlineState;
    });

    refreshCloudBtn.addEventListener("click", refreshCloudGroups);
    pullCloudBtn.addEventListener("click", pullSelectedCloudGroup);

    /***********************
     * SUPABASE SYNC
     ***********************/
    function buildRowsForDb(){
      const rows = [];
      ZONES.forEach(z=>{
        z.tasks.forEach(task=>{
          const key = zoneTaskKey(z.id, task);
          students.forEach(st=>{
            const status = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            if(!status) return;
            rows.push({
              group_name: currentGroup,
              student: st,
              zone: z.id,
              task: task,
              status: status
            });
          });
        });
      });
      return rows;
    }

    async function syncNow(){
      if(!currentGroup || students.length === 0) return;
      if(syncingNow) return;

      syncingNow = true;
      setOnlineBanner(onlineState, "Syncing...");

      const canReach = await checkCloudReachable();
      if(!canReach){
        syncingNow = false;
        setOnlineBanner(false, "Local only");
        return;
      }

      try{
        await db.from("courses").upsert(
          [{ group_name: currentGroup, is_closed: false }],
          { onConflict: "group_name" }
        );

        const del = await db.from("evaluations").delete().eq("group_name", currentGroup);
        if(del.error){
          console.warn("Delete error:", del.error);
        }

        const rows = buildRowsForDb();
        if(rows.length > 0){
          const ins = await db.from("evaluations").insert(rows);
          if(ins.error){
            console.error(ins.error);
            setMessage("Sync failed: could not write to cloud. Local marks are safe.", true);
            syncingNow = false;
            setOnlineBanner(true, "Sync error");
            return;
          }
        }

        syncingNow = false;
        setOnlineBanner(true, "Synced");
      }catch(e){
        console.error(e);
        syncingNow = false;
        setMessage("Sync failed. Local marks are safe.", true);
        setOnlineBanner(false, "Local only");
      }
    }

    let syncTimer = null;
    function scheduleSync(){
      if(syncTimer) clearTimeout(syncTimer);
      syncTimer = setTimeout(async ()=>{ await syncNow(); }, 900);
    }

    /***********************
     * CSV
     ***********************/
    function exportCsv(){
      if(!currentGroup || students.length === 0){
        setMessage("Enter a group and students first.", true);
        return;
      }

      const headers = ["group_name","student","zone","task","status"];
      const lines = [headers.join(",")];

      ZONES.forEach(z=>{
        z.tasks.forEach(task=>{
          const key = zoneTaskKey(z.id, task);
          students.forEach(st=>{
            const status = (marks[key] && marks[key][st]) ? marks[key][st] : "";
            if(!status) return;

            const row = {
              group_name: currentGroup,
              student: st,
              zone: z.id,
              task: task,
              status: status
            };

            const values = headers.map(h=>{
              let v = row[h];
              if(v == null) v = "";
              v = String(v).replace(/"/g,'""');
              if(v.search(/[",\n]/) !== -1) v = `"${v}"`;
              return v;
            });

            lines.push(values.join(","));
          });
        });
      });

      const content = lines.join("\n");
      const blob = new Blob([content], {type:"text/csv;charset=utf-8;"});
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `snowboard_assessment_${currentGroup.replace(/\s+/g,"_")}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      setMessage("CSV exported for this group.", false);
    }

    /***********************
     * EVENTS
     ***********************/
    applyBtn.addEventListener("click", async ()=>{
      clearMessage();

      const g = normGroupName(groupNameEl.value);
      if(!g){
        setMessage("Enter a group name.", true);
        return;
      }

      const st = parseStudents(studentsInputEl.value);
      if(st.length === 0){
        setMessage("Enter at least one student name.", true);
        return;
      }

      currentGroup = g;
      students = st;

      const existing = getLocalGroup(currentGroup);
      if(existing){
        marks = existing.marks || {};
        ensureMarksShape();
        saveCurrentGroupLocal("Loaded existing local group and kept marks.");
      }else{
        buildEmptyMarks();
        saveCurrentGroupLocal("Group created locally.");
      }

      renderGrid();
      await checkCloudReachable();
      scheduleSync();
      setMessage("Layout applied.", false);
    });

    loadLocalBtn.addEventListener("click", ()=>{
      clearMessage();
      const g = normGroupName(groupNameEl.value);
      if(!g){
        setMessage("Enter a group name, or select a saved group.", true);
        return;
      }
      const ok = loadGroupFromLocal(g);
      if(!ok) setMessage("No local marks found for that group name.", true);
    });

    useGroupBtn.addEventListener("click", ()=>{
      clearMessage();
      const selected = savedGroupsSelect.value;
      if(!selected){
        setMessage("Select a saved group first.", true);
        return;
      }
      const ok = loadGroupFromLocal(selected);
      if(!ok){
        setMessage("Could not load that saved group.", true);
      }else{
        scheduleSync();
      }
    });

    exportCsvBtn.addEventListener("click", exportCsv);

    async function heartbeat(){
      if(syncingNow) return;
      await checkCloudReachable();
    }

    /***********************
     * INIT
     ***********************/
    (async function init(){
      refreshSavedGroupsDropdown();
      clearCloudDropdown();
      setOnlineBanner(false, "Checking...");
      await checkCloudReachable();
      setInterval(heartbeat, 12000);
    })();
  </script>
</body>
</html>