<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snowboard Assessment Grid</title>

  <!-- Supabase JS (browser) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 16px;
      background: #f4f6f8;
      color: #111;
    }

    h1 { margin: 0 0 6px 0; font-size: 40px; line-height: 1.05; }
    .small { font-size: 0.95rem; color: #444; margin-bottom: 12px; }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      margin: 12px 0 10px 0;
    }

    label { font-weight: 600; }
    input[type="text"], select {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #c9d1d9;
      font-size: 1rem;
      background: #fff;
      min-width: 260px;
      max-width: 420px;
    }

    button {
      padding: 10px 14px;
      border: 1px solid #1f2328;
      border-radius: 10px;
      background: #2f6f3a;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      font-size: 1rem;
    }
    button.secondary { background: #4a4f56; border-color: #3d4248; }
    button.ghost { background: #fff; color: #111; border-color: #c9d1d9; }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    .statusbar {
      margin-top: 10px;
      border: 2px solid #d0d7de;
      border-radius: 10px;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #fff;
    }
    .status-left {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
    }
    .dot {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      display: inline-block;
      background: #bbb;
      border: 2px solid #fff;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
    }
    .dot.online { background: #2da44e; }
    .dot.offline { background: #d1242f; }

    .status-msg { font-weight: 800; }
    .status-msg.ok { color: #1a7f37; }
    .status-msg.warn { color: #9a6700; }
    .status-msg.err { color: #cf222e; }

    .divider {
      height: 5px;
      background: #111;
      margin: 10px 0 10px 0;
    }

    /* Modal */
    .modalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .modal {
      width: min(860px, 95vw);
      max-height: 85vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      border: 2px solid #111;
      box-shadow: 0 12px 40px rgba(0,0,0,0.2);
    }
    .modalHead {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 14px;
      border-bottom: 2px solid #111;
      background: #f6f8fa;
      border-top-left-radius: 14px;
      border-top-right-radius: 14px;
      gap: 10px;
    }
    .modalTitle {
      font-weight: 900;
      font-size: 1.15rem;
    }
    .modalClose {
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
      color: #111;
      border: 2px solid #111;
      font-weight: 900;
    }
    .modalBody {
      padding: 14px;
      font-size: 1rem;
      line-height: 1.35;
    }
    .modalBody ul { margin: 8px 0 0 20px; }

    /* Table wrapper */
    .tableWrap {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      background: #fff;
      border: 3px solid #111;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed; /* critical */
      font-size: 18px;
    }

    th, td {
      border: 3px solid #111;
      padding: 10px 10px;
      vertical-align: middle;
      text-align: left;
      background: #fff;
    }

    th {
      background: #eee;
      font-weight: 900;
      text-align: center;
    }

    /* Task column sizing */
    th.taskCol, td.taskCol {
      width: clamp(160px, 34vw, 260px);
      max-width: clamp(160px, 34vw, 260px);
      white-space: normal;
      word-break: break-word;
      overflow-wrap: anywhere;
      text-align: left;
      background: #fff;
    }

    /* Mark columns sizing */
    th.markCol, td.markCol {
      width: 66px;
      min-width: 66px;
      text-align: center;
      padding: 8px;
    }

    @media (max-width: 520px) {
      th.taskCol, td.taskCol {
        width: clamp(140px, 30vw, 210px);
        max-width: clamp(140px, 30vw, 210px);
      }
      th.markCol, td.markCol {
        width: 58px;
        min-width: 58px;
      }
      table { font-size: 16px; }
    }

    /* Column color backgrounds */
    .col-inc { background: #f6dfe2; } /* light red */
    .col-con { background: #faf1cf; } /* light yellow */
    .col-refi { background: #dff0df; } /* light green */

    /* Clickable mark button inside cell */
    .markBtn {
      width: 42px;
      height: 42px;
      border-radius: 8px;
      border: 2px solid #9aa4ad;
      background: #e9edf1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 1000;
      font-size: 24px;
      color: #111;
      user-select: none;
    }

    /* Checked state uses the column color, with a slightly stronger fill */
    .checked.col-inc .markBtn { background: #e45b6b; border-color: #c73b4a; color: #fff; }
    .checked.col-con .markBtn { background: #e0b93f; border-color: #c59f2b; color: #111; }
    .checked.col-refi .markBtn { background: #3f8c4a; border-color: #2f6f3a; color: #fff; }

    /* Zone header row */
    .zoneRow td {
      font-weight: 900;
      background: #dfeefe;
    }
    .zoneRow.zone2 td { background: #e5f3e7; }
    .zoneRow.zone3 td { background: #e9e7fb; }

    .zoneTitle {
      display: flex;
      align-items: center;
      gap: 10px;
      justify-content: space-between;
    }
    .zoneLabel {
      display: inline-flex;
      flex-direction: column;
      gap: 2px;
    }
    .zoneLabel .zTop { font-size: 22px; }
    .zoneLabel .zSub { font-size: 18px; font-weight: 800; color: #444; }

    /* Info icon (lowercase i in a circle) */
    .infoBtn {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      border: 2px solid #111;
      background: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      flex: 0 0 auto;
    }

    .hintRed {
      margin: 10px 0 0 0;
      font-weight: 900;
      color: #b42318;
    }
  </style>
</head>

<body>
  <h1>Snowboard Assessment</h1>
  <div class="small">
    Tap a square to set Inc (red), Con (yellow), or Refi (green). Data is saved locally first and synced to Supabase automatically when possible.
  </div>

  <div class="controls">
    <label for="groupName">Group name:</label>
    <input id="groupName" type="text" placeholder="Example: Lake Louise Group A" />

    <label for="students">Students:</label>
    <input id="students" type="text" placeholder="Example: 1 Albert, 2 Benedict, 3 Reuben" />

    <button id="applyLayoutBtn">Apply layout</button>
    <button id="exportBtn" class="secondary">Export CSV (this group)</button>
    <button id="loadLocalBtn">Load saved marks</button>
  </div>

  <div class="controls">
    <label for="savedGroups">Saved groups:</label>
    <select id="savedGroups">
      <option value="">Select a saved group</option>
    </select>

    <button id="useGroupBtn" class="secondary">Use group</button>
    <button id="pullCloudBtn" class="secondary">Pull from cloud</button>
  </div>

  <div class="statusbar" id="statusBar">
    <div class="status-left">
      <span class="dot offline" id="netDot"></span>
      <span id="netText">Offline: using local storage.</span>
    </div>
    <div class="status-msg" id="syncText">Synced</div>
  </div>

  <div class="hintRed" id="hintText" style="display:none;"></div>

  <div class="divider"></div>

  <div class="tableWrap">
    <table id="gridTable"></table>
  </div>

  <!-- Modal -->
  <div id="modalOverlay" class="modalOverlay" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <div id="modalTitle" class="modalTitle"></div>
        <button id="modalClose" class="modalClose">Close</button>
      </div>
      <div id="modalBody" class="modalBody"></div>
    </div>
  </div>

  <script>
    /***********************
     * Supabase config
     ***********************/
    // Replace these two lines with your real values from Supabase:
    const SUPABASE_URL = "https://ynlzmelrlbgflcabvvfs.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InlubHptZWxybGJnZmxjYWJ2dmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MTYwNjYsImV4cCI6MjA3OTk5MjA2Nn0.6ylCGmMmKsShchJxsTLsLbIHwdKra0bxu4dRgs86jkE";

    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // IMPORTANT: you said you created Participant_Map (capital P and M) in courses.
    // Postgres folds unquoted identifiers to lowercase. If you created it as Participant_Map without quotes,
    // it likely became participant_map. If you created it with quotes, it stays Participant_Map.
    // Put the exact column name here:
    const COURSE_PARTICIPANT_MAP_COL = "participant_map"; // change to "Participant_Map" if you truly quoted it

    /***********************
     * Data model
     ***********************/
    const ZONES = [
      {
        zone: 1,
        header: "Zone 1",
        title: "FLATS AND MAGIC CARPET AREA",
        tasks: [
          "Skating in a Straight Line",
          "Skating Around Cones",
          "Skating Across a Slope (Both Edges)",
          "Switch Skating",
          "J-Turns (One-Footed)"
        ],
        infoTitle: "Zone 1: Flats and Magic Carpet Area",
        infoHtml: `
          <div><b>Possible Constraints</b></div>
          <ul>
            <li>Glide with reduced space or toward a target marker.</li>
            <li>Perform skating tasks with a variable snow surface (slightly packed or soft).</li>
            <li>Skating around obstacles (example: cones, stubbies).</li>
            <li>Use minor slope gradient to encourage longer glide or speed awareness.</li>
          </ul>
          <div style="margin-top:10px;"><b>Evaluation Focus</b></div>
          <ul>
            <li>Balance and coordination while gliding</li>
            <li>Smooth push and glide transitions</li>
            <li>Controlled direction and stopping</li>
            <li>Awareness of surrounding space and other riders</li>
          </ul>
        `
      },
      {
        zone: 2,
        header: "Zone 2",
        title: "BUNNY HILL, MAGIC CARPET (GENTLE SLOPES)",
        tasks: [
          "Riding the Lift (magic carpet, t-bar, or chair)",
          "Standing on Both Edges",
          "Side Slipping (Both Edges)",
          "Traversing (Both Edges)",
          "Linked Turns"
        ],
        infoTitle: "Zone 2: Bunny Hill, Magic Carpet (Gentle Slopes)",
        infoHtml: `
          <div><b>Possible Variations</b></div>
          <ul>
            <li>Perform a controlled stop during a sideslip or traverse.</li>
            <li>Link multiple turns with slight changes in snow texture or slope pitch.</li>
            <li>Ride both toe and heel sides in the same run.</li>
            <li>Follow a marked path or cone line to encourage directional awareness.</li>
          </ul>
          <div style="margin-top:10px;"><b>Evaluation Focus</b></div>
          <ul>
            <li>Smooth loading and unloading of the magic carpet</li>
            <li>Balanced posture while standing on both edges</li>
            <li>Controlled side slips without abrupt stops</li>
            <li>Stable traverses across the slope</li>
            <li>Linked turns showing direction and speed control</li>
          </ul>
        `
      },
      {
        zone: 3,
        header: "Zone 3",
        title: "FLAGGED GREEN RUN",
        tasks: [
          "Linked Turns (Continuous)",
          "Speed Control Through Turn Shape",
          "Edge Release and Engagement",
          "Flow and Continuity",
          "Adaptability"
        ],
        infoTitle: "Zone 3: Flagged Green Run",
        infoHtml: `
          <div><b>Evaluation Focus</b></div>
          <ul>
            <li>Continuous linked turns along the flagged path</li>
            <li>Speed managed through turn shape, not braking</li>
            <li>Controlled edge release and engagement</li>
            <li>Flow maintained through variable turn timing</li>
            <li>Adaptability to terrain, snow, and surrounding traffic</li>
          </ul>
        `
      }
    ];

    const MARKS = ["Inc", "Con", "Refi"];
    const MARK_CLASS = { "Inc": "col-inc", "Con": "col-con", "Refi": "col-refi" };

    /***********************
     * Local storage keys
     ***********************/
    const LS_GROUP_LIST = "sb_groups_v2"; // array of group names
    const lsGroupMetaKey = (groupName) => `sb_groupmeta_v2_${groupName}`; // {group_name, studentsText, participants, participant_map}
    const lsMarksKey = (groupName) => `sb_marks_v2_${groupName}`; // { [student][zone][task] : "Inc|Con|Refi" }

    /***********************
     * UI state
     ***********************/
    let currentGroupName = "";
    let currentParticipants = []; // [{key, label, orderKey}]
    let currentMarks = {}; // flat map by composite key

    /***********************
     * Modal helpers
     ***********************/
    const modalOverlay = document.getElementById("modalOverlay");
    const modalTitle = document.getElementById("modalTitle");
    const modalBody = document.getElementById("modalBody");
    document.getElementById("modalClose").addEventListener("click", closeModal);
    modalOverlay.addEventListener("click", (e) => { if (e.target === modalOverlay) closeModal(); });

    function openModal(title, html) {
      modalTitle.textContent = title;
      modalBody.innerHTML = html;
      modalOverlay.style.display = "flex";
    }
    function closeModal() {
      modalOverlay.style.display = "none";
    }

    /***********************
     * Status helpers
     ***********************/
    const netDot = document.getElementById("netDot");
    const netText = document.getElementById("netText");
    const syncText = document.getElementById("syncText");
    const hintText = document.getElementById("hintText");

    function setHint(msg) {
      if (!msg) {
        hintText.style.display = "none";
        hintText.textContent = "";
        return;
      }
      hintText.style.display = "block";
      hintText.textContent = msg;
    }

    function setSyncStatus(msg, kind) {
      syncText.textContent = msg || "";
      syncText.classList.remove("ok", "warn", "err");
      if (kind) syncText.classList.add(kind);
    }

    async function cloudReachable() {
      if (!navigator.onLine) return false;
      try {
        const { error } = await supabaseClient
          .from("courses")
          .select("group_name")
          .limit(1);
        return !error;
      } catch (e) {
        return false;
      }
    }

    async function refreshNetStatus() {
      const reachable = await cloudReachable();
      if (reachable) {
        netDot.classList.remove("offline");
        netDot.classList.add("online");
        netText.textContent = "Online: cloud is reachable.";
        setSyncStatus("Synced", "ok");
      } else {
        netDot.classList.remove("online");
        netDot.classList.add("offline");
        netText.textContent = "Offline: using local storage.";
        setSyncStatus("Synced", "warn");
      }
    }

    window.addEventListener("online", async () => {
      await refreshNetStatus();
      await loadCloudGroupsIntoDropdown(); // refresh list when back online
      await trySyncCurrentGroup();
    });

    window.addEventListener("offline", async () => {
      await refreshNetStatus();
    });

    /***********************
     * Participants parsing and ordering
     ***********************/
    function parseStudentsInput(studentsText) {
      const raw = (studentsText || "")
        .split(",")
        .map(s => s.trim())
        .filter(Boolean);

      const parsed = raw.map(item => {
        // If starts with number(s), treat as bib number prefix
        const m = item.match(/^(\d+)\s+(.*)$/);
        if (m) {
          const bib = parseInt(m[1], 10);
          const name = (m[2] || "").trim();
          const label = `${bib} ${name}`.trim();
          return {
            key: label,               // store as full label for evaluations.student
            label,
            orderKey: { type: "bib", bib, name: name.toLowerCase() }
          };
        }

        // Otherwise treat as name only
        return {
          key: item,
          label: item,
          orderKey: { type: "name", name: item.toLowerCase() }
        };
      });

      // Sorting rule:
      // If any bib entries exist, sort bib entries by bib asc, then name, then non-bib by name.
      const hasBib = parsed.some(p => p.orderKey.type === "bib");
      if (hasBib) {
        parsed.sort((a,b) => {
          const ta = a.orderKey.type, tb = b.orderKey.type;
          if (ta !== tb) return ta === "bib" ? -1 : 1;
          if (ta === "bib") {
            if (a.orderKey.bib !== b.orderKey.bib) return a.orderKey.bib - b.orderKey.bib;
            return (a.orderKey.name || "").localeCompare(b.orderKey.name || "");
          }
          return (a.orderKey.name || "").localeCompare(b.orderKey.name || "");
        });
      } else {
        parsed.sort((a,b) => (a.orderKey.name || "").localeCompare(b.orderKey.name || ""));
      }

      return parsed;
    }

    function buildParticipantMap(participants) {
      // Store minimal mapping for now: key -> label (they are identical currently)
      // Later, you can use this to map "Name" to "Bib + Name" or vice versa.
      const map = {};
      for (const p of participants) map[p.key] = p.label;
      return map;
    }

    /***********************
     * Local storage helpers
     ***********************/
    function getLocalGroupNames() {
      try {
        const arr = JSON.parse(localStorage.getItem(LS_GROUP_LIST) || "[]");
        return Array.isArray(arr) ? arr : [];
      } catch {
        return [];
      }
    }

    function addLocalGroupName(name) {
      const n = (name || "").trim();
      if (!n) return;
      const list = getLocalGroupNames();
      if (!list.includes(n)) {
        list.push(n);
        list.sort((a,b) => a.localeCompare(b));
        localStorage.setItem(LS_GROUP_LIST, JSON.stringify(list));
      }
    }

    function saveGroupMetaLocal(meta) {
      if (!meta || !meta.group_name) return;
      localStorage.setItem(lsGroupMetaKey(meta.group_name), JSON.stringify(meta));
      addLocalGroupName(meta.group_name);
    }

    function loadGroupMetaLocal(groupName) {
      try {
        const raw = localStorage.getItem(lsGroupMetaKey(groupName));
        return raw ? JSON.parse(raw) : null;
      } catch {
        return null;
      }
    }

    function saveMarksLocal(groupName, marksMap) {
      localStorage.setItem(lsMarksKey(groupName), JSON.stringify(marksMap || {}));
      addLocalGroupName(groupName);
    }

    function loadMarksLocal(groupName) {
      try {
        const raw = localStorage.getItem(lsMarksKey(groupName));
        return raw ? JSON.parse(raw) : {};
      } catch {
        return {};
      }
    }

    /***********************
     * Cloud groups dropdown (only is_closed = false)
     ***********************/
    async function loadCloudGroupsIntoDropdown() {
      const localNames = getLocalGroupNames();
      let cloudNames = [];

      const reachable = await cloudReachable();
      if (reachable) {
        try {
          const { data, error } = await supabaseClient
            .from("courses")
            .select("group_name, is_closed")
            .eq("is_closed", false)
            .order("group_name", { ascending: true });

          if (error) throw error;

          cloudNames = [...new Set((data || [])
            .map(r => (r.group_name || "").trim())
            .filter(Boolean))];
        } catch (e) {
          // ignore, fall back to local list only
          cloudNames = [];
        }
      }

      rebuildSavedGroupsDropdown(localNames, cloudNames);
    }

    function rebuildSavedGroupsDropdown(localNames, cloudNames) {
      const select = document.getElementById("savedGroups");
      select.innerHTML = "";

      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = "Select a saved group";
      select.appendChild(opt0);

      const localSet = new Set(localNames);
      const merged = [...localNames, ...cloudNames.filter(n => !localSet.has(n))];

      for (const name of merged) {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      }
    }

    function getRequestedGroupName() {
      const typed = (document.getElementById("groupName").value || "").trim();
      if (typed) return typed;
      const selected = (document.getElementById("savedGroups").value || "").trim();
      return selected || "";
    }

    /***********************
     * Grid building
     ***********************/
    function keyFor(studentKey, zone, task) {
      return `${studentKey}||${zone}||${task}`;
    }

    function renderGrid() {
      const table = document.getElementById("gridTable");
      table.innerHTML = "";

      if (!currentParticipants.length) return;

      // Header row 1: Task + participant names (colspan 3 each)
      const tr1 = document.createElement("tr");

      const thTask = document.createElement("th");
      thTask.className = "taskCol";
      thTask.textContent = "Task";
      tr1.appendChild(thTask);

      for (const p of currentParticipants) {
        const thP = document.createElement("th");
        thP.colSpan = 3;
        thP.textContent = p.label;
        tr1.appendChild(thP);
      }
      table.appendChild(tr1);

      // Header row 2: blank under Task + Inc/Con/Refi for each participant
      const tr2 = document.createElement("tr");
      const thBlank = document.createElement("th");
      thBlank.className = "taskCol";
      thBlank.textContent = "";
      tr2.appendChild(thBlank);

      for (let i = 0; i < currentParticipants.length; i++) {
        for (const m of MARKS) {
          const th = document.createElement("th");
          th.className = `markCol ${MARK_CLASS[m]}`;
          th.textContent = m;
          tr2.appendChild(th);
        }
      }
      table.appendChild(tr2);

      // Body: zones + tasks
      for (const z of ZONES) {
        // Zone header row
        const ztr = document.createElement("tr");
        ztr.className = "zoneRow " + (z.zone === 2 ? "zone2" : z.zone === 3 ? "zone3" : "");

        const ztdTask = document.createElement("td");
        ztdTask.className = "taskCol";
        const wrap = document.createElement("div");
        wrap.className = "zoneTitle";

        const label = document.createElement("div");
        label.className = "zoneLabel";
        label.innerHTML = `<div class="zTop">${z.header} <span class="zSub">${z.title}</span></div>`;

        const infoBtn = document.createElement("button");
        infoBtn.type = "button";
        infoBtn.className = "infoBtn";
        infoBtn.textContent = "i"; // lowercase i
        infoBtn.addEventListener("click", () => openModal(z.infoTitle, z.infoHtml));

        wrap.appendChild(label);
        wrap.appendChild(infoBtn);
        ztdTask.appendChild(wrap);
        ztr.appendChild(ztdTask);

        // zone header row: one big cell per participant (colspan 3)
        for (const p of currentParticipants) {
          const td = document.createElement("td");
          td.colSpan = 3;
          td.style.textAlign = "center";
          td.style.fontWeight = "900";
          td.textContent = p.label;
          ztr.appendChild(td);
        }

        table.appendChild(ztr);

        // Task rows
        for (const task of z.tasks) {
          const tr = document.createElement("tr");

          const tdTask = document.createElement("td");
          tdTask.className = "taskCol";
          tdTask.textContent = task;
          tr.appendChild(tdTask);

          for (const p of currentParticipants) {
            for (const m of MARKS) {
              const td = document.createElement("td");
              td.className = `markCol ${MARK_CLASS[m]}`;
              td.dataset.student = p.key;
              td.dataset.zone = String(z.zone);
              td.dataset.task = task;
              td.dataset.mark = m;

              const btn = document.createElement("div");
              btn.className = "markBtn";
              btn.textContent = ""; // we set checkmark on checked cells
              td.appendChild(btn);

              td.addEventListener("click", () => onCellClick(td));

              // set initial checked state
              const k = keyFor(p.key, z.zone, task);
              if (currentMarks[k] === m) {
                td.classList.add("checked");
                btn.textContent = "✓";
              }

              tr.appendChild(td);
            }
          }

          table.appendChild(tr);
        }
      }
    }

    function onCellClick(td) {
      if (!currentGroupName) {
        setHint("Enter a group name and apply layout first.");
        return;
      }
      setHint("");

      const student = td.dataset.student;
      const zone = parseInt(td.dataset.zone, 10);
      const task = td.dataset.task;
      const mark = td.dataset.mark;

      const k = keyFor(student, zone, task);

      // Clicking the same mark toggles it off
      const isSame = currentMarks[k] === mark;
      if (isSame) {
        delete currentMarks[k];
      } else {
        currentMarks[k] = mark;
      }

      // Update UI for this student/zone/task: clear all 3, then set selected
      const rowCells = document.querySelectorAll(
        `td.markCol[data-student="${cssEscape(student)}"][data-zone="${zone}"][data-task="${cssEscape(task)}"]`
      );

      rowCells.forEach(c => {
        c.classList.remove("checked");
        const b = c.querySelector(".markBtn");
        if (b) b.textContent = "";
      });

      if (!isSame) {
        td.classList.add("checked");
        const b = td.querySelector(".markBtn");
        if (b) b.textContent = "✓";
      }

      // Save local immediately
      saveMarksLocal(currentGroupName, currentMarks);

      // Sync if possible
      trySyncSingleMark(student, zone, task, currentMarks[k] || null);
    }

    function cssEscape(s) {
      // minimal escape for attribute selectors
      return String(s).replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }

    /***********************
     * Cloud syncing
     ***********************/
    async function upsertCourseToCloud(meta) {
      const reachable = await cloudReachable();
      if (!reachable) return false;

      const payload = {
        group_name: meta.group_name,
        is_closed: false,
        students: meta.studentsText || "",
      };
      payload[COURSE_PARTICIPANT_MAP_COL] = meta.participant_map || {};

      const { error } = await supabaseClient
        .from("courses")
        .upsert(payload, { onConflict: "group_name" });

      if (error) throw error;
      return true;
    }

    async function upsertEvaluationMark(groupName, student, zone, task, mark) {
      const reachable = await cloudReachable();
      if (!reachable) return false;

      // If mark is null, we delete the row for that mark (so "toggle off" clears cloud)
      if (mark === null) {
        const { error } = await supabaseClient
          .from("evaluations")
          .delete()
          .eq("group_name", groupName)
          .eq("student", student)
          .eq("zone", zone)
          .eq("task", task);

        if (error) throw error;
        return true;
      }

      const payload = {
        group_name: groupName,
        student,
        zone,
        task,
        mark
      };

      const { error } = await supabaseClient
        .from("evaluations")
        .upsert(payload, { onConflict: "group_name,student,zone,task" });

      if (error) throw error;
      return true;
    }

    async function trySyncSingleMark(student, zone, task, markOrNull) {
      const reachable = await cloudReachable();
      if (!reachable) {
        setSyncStatus("Saved locally", "warn");
        return;
      }

      try {
        setSyncStatus("Syncing...", "warn");
        await upsertEvaluationMark(currentGroupName, student, zone, task, markOrNull);
        setSyncStatus("Synced", "ok");
      } catch (e) {
        setSyncStatus("Saved locally", "warn");
      }
    }

    async function trySyncCurrentGroup() {
      if (!currentGroupName || !currentParticipants.length) return;

      const reachable = await cloudReachable();
      if (!reachable) return;

      try {
        setSyncStatus("Syncing...", "warn");

        // Ensure course exists and is open
        const meta = loadGroupMetaLocal(currentGroupName);
        if (meta) await upsertCourseToCloud(meta);

        // Bulk upsert marks
        const rows = [];
        for (const k in currentMarks) {
          const [student, zoneStr, task] = k.split("||");
          rows.push({
            group_name: currentGroupName,
            student,
            zone: parseInt(zoneStr, 10),
            task,
            mark: currentMarks[k]
          });
        }

        // Upsert in chunks
        const chunkSize = 250;
        for (let i = 0; i < rows.length; i += chunkSize) {
          const chunk = rows.slice(i, i + chunkSize);
          const { error } = await supabaseClient
            .from("evaluations")
            .upsert(chunk, { onConflict: "group_name,student,zone,task" });
          if (error) throw error;
        }

        setSyncStatus("Synced", "ok");
      } catch (e) {
        setSyncStatus("Saved locally", "warn");
      }
    }

    /***********************
     * Pull group from cloud
     ***********************/
    async function pullGroupFromCloud(groupName) {
      const reachable = await cloudReachable();
      if (!reachable) {
        setHint("Cloud is not reachable. Try again when online.");
        return;
      }

      setHint("");
      setSyncStatus("Pulling...", "warn");

      // 1) Get course meta
      const { data: courseRows, error: courseErr } = await supabaseClient
        .from("courses")
        .select(`group_name, students, is_closed, ${COURSE_PARTICIPANT_MAP_COL}`)
        .eq("group_name", groupName)
        .eq("is_closed", false)
        .limit(1);

      if (courseErr) {
        setSyncStatus("Saved locally", "warn");
        setHint("Could not read course from cloud.");
        return;
      }

      if (!courseRows || !courseRows.length) {
        setSyncStatus("Saved locally", "warn");
        setHint("No open course found in cloud with that group name.");
        return;
      }

      const course = courseRows[0];
      const studentsText = (course.students || "").trim();
      const participants = parseStudentsInput(studentsText);
      const participant_map = course[COURSE_PARTICIPANT_MAP_COL] || buildParticipantMap(participants);

      // 2) Get evaluations
      const { data: evalRows, error: evalErr } = await supabaseClient
        .from("evaluations")
        .select("student, zone, task, mark")
        .eq("group_name", groupName);

      if (evalErr) {
        setSyncStatus("Saved locally", "warn");
        setHint("Course loaded, but evaluations could not be read.");
        return;
      }

      const marksMap = {};
      for (const r of (evalRows || [])) {
        const k = keyFor(r.student, r.zone, r.task);
        marksMap[k] = r.mark;
      }

      // Save local and load into UI
      const meta = {
        group_name: groupName,
        studentsText,
        participants,
        participant_map
      };

      saveGroupMetaLocal(meta);
      saveMarksLocal(groupName, marksMap);

      // Load into UI
      document.getElementById("groupName").value = groupName;
      document.getElementById("students").value = studentsText;

      currentGroupName = groupName;
      currentParticipants = participants;
      currentMarks = marksMap;

      renderGrid();
      setSyncStatus("Synced", "ok");
      setHint("Pulled from cloud and saved locally.");

      // Refresh dropdown list (open courses only)
      await loadCloudGroupsIntoDropdown();
    }

    /***********************
     * CSV export
     ***********************/
    function exportCSV() {
      if (!currentGroupName || !currentParticipants.length) {
        setHint("Apply layout first.");
        return;
      }

      const rows = [];
      rows.push(["group_name","student","zone","task","mark"].join(","));

      for (const k in currentMarks) {
        const [student, zoneStr, task] = k.split("||");
        const mark = currentMarks[k];
        rows.push([
          csvEscape(currentGroupName),
          csvEscape(student),
          csvEscape(zoneStr),
          csvEscape(task),
          csvEscape(mark)
        ].join(","));
      }

      const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = `${currentGroupName}_marks.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function csvEscape(v) {
      const s = String(v ?? "");
      if (/[,"\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
      return s;
    }

    /***********************
     * Event handlers
     ***********************/
    document.getElementById("applyLayoutBtn").addEventListener("click", async () => {
      const groupName = (document.getElementById("groupName").value || "").trim();
      const studentsText = (document.getElementById("students").value || "").trim();

      if (!groupName) {
        setHint("Enter a group name.");
        return;
      }
      if (!studentsText) {
        setHint("Enter students as comma-separated values.");
        return;
      }

      setHint("");

      const participants = parseStudentsInput(studentsText);
      const participant_map = buildParticipantMap(participants);

      currentGroupName = groupName;
      currentParticipants = participants;

      // Load any local marks already
      currentMarks = loadMarksLocal(groupName) || {};

      // Save meta locally
      const meta = {
        group_name: groupName,
        studentsText,
        participants,
        participant_map
      };
      saveGroupMetaLocal(meta);

      // Render
      renderGrid();

      // Sync course and marks
      try {
        setSyncStatus("Syncing...", "warn");
        await upsertCourseToCloud(meta);
        await trySyncCurrentGroup();
        setSyncStatus("Synced", "ok");
      } catch (e) {
        setSyncStatus("Saved locally", "warn");
      }

      await loadCloudGroupsIntoDropdown();
    });

    document.getElementById("loadLocalBtn").addEventListener("click", () => {
      const groupName = getRequestedGroupName();
      if (!groupName) {
        setHint("Select a saved group or type a group name.");
        return;
      }

      const meta = loadGroupMetaLocal(groupName);
      if (!meta) {
        setHint("No local saved data found for that group.");
        return;
      }

      document.getElementById("groupName").value = meta.group_name;
      document.getElementById("students").value = meta.studentsText || "";

      currentGroupName = meta.group_name;
      currentParticipants = meta.participants || parseStudentsInput(meta.studentsText || "");
      currentMarks = loadMarksLocal(groupName) || {};

      renderGrid();
      setHint("");
    });

    document.getElementById("useGroupBtn").addEventListener("click", () => {
      const sel = (document.getElementById("savedGroups").value || "").trim();
      if (!sel) {
        setHint("Select a group from the dropdown.");
        return;
      }
      document.getElementById("groupName").value = sel;

      const meta = loadGroupMetaLocal(sel);
      if (meta) document.getElementById("students").value = meta.studentsText || "";

      setHint("");
    });

    document.getElementById("pullCloudBtn").addEventListener("click", async () => {
      const groupName = getRequestedGroupName();
      if (!groupName) {
        setHint("Select a saved group or type the group name to pull from the cloud.");
        return;
      }
      await pullGroupFromCloud(groupName);
    });

    document.getElementById("exportBtn").addEventListener("click", exportCSV);

    /***********************
     * Init
     ***********************/
    document.addEventListener("DOMContentLoaded", async () => {
      await refreshNetStatus();
      await loadCloudGroupsIntoDropdown();

      // If user typed a group name already and wants to load local quickly
      setHint("");
    });
  </script>
</body>
</html>